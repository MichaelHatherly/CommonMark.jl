var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#CommonMark.Admonition","page":"API Reference","title":"CommonMark.Admonition","text":"Admonition callout box. Build with Node(Admonition, category, title, children...).\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.AdmonitionRule","page":"API Reference","title":"CommonMark.AdmonitionRule","text":"AdmonitionRule()\n\nParse admonition blocks (notes, warnings, tips, etc.).\n\nNot enabled by default. Uses !!! syntax with a category and optional title.\n\n!!! note \"Custom Title\"\n    This is an admonition block.\n    It can contain multiple paragraphs.\n\n!!! warning\n    Default title is the category name.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.AsteriskEmphasisRule","page":"API Reference","title":"CommonMark.AsteriskEmphasisRule","text":"AsteriskEmphasisRule()\n\nParse emphasis using asterisks (* and **).\n\nEnabled by default. Single for italic, double for bold.\n\n*italic* and **bold** and ***both***\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.AttributeRule","page":"API Reference","title":"CommonMark.AttributeRule","text":"AttributeRule()\n\nParse attribute syntax to attach metadata to elements.\n\nNot enabled by default. Uses {#id .class key=value} syntax after elements.\n\n# Heading {#custom-id .highlight}\n\nParagraph with attributes.\n{.note}\n\n[Link](url){target=_blank}\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.AtxHeadingRule","page":"API Reference","title":"CommonMark.AtxHeadingRule","text":"AtxHeadingRule()\n\nParse ATX-style headings (# Heading).\n\nEnabled by default. Supports levels 1-6 with corresponding number of # characters.\n\n# Heading 1\n## Heading 2\n### Heading 3\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.AutoIdentifierRule","page":"API Reference","title":"CommonMark.AutoIdentifierRule","text":"AutoIdentifierRule()\n\nAutomatically generate IDs for headings.\n\nNot enabled by default. IDs are slugified from heading text. Duplicate IDs get numeric suffixes. Headings with explicit IDs (via AttributeRule) are preserved.\n\n# My Heading        → <h1 id=\"my-heading\">\n# My Heading        → <h1 id=\"my-heading-1\"> (duplicate)\n# Custom {#my-id}   → <h1 id=\"my-id\"> (with AttributeRule)\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.AutolinkRule","page":"API Reference","title":"CommonMark.AutolinkRule","text":"AutolinkRule()\n\nParse autolinks (<url> and <email@example.com>).\n\nEnabled by default. URLs must include a scheme.\n\n<https://example.com>\n<user@example.com>\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.BlockQuote","page":"API Reference","title":"CommonMark.BlockQuote","text":"Block quote containing other block elements.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.BlockQuoteRule","page":"API Reference","title":"CommonMark.BlockQuoteRule","text":"BlockQuoteRule()\n\nParse block quotes (> quoted text).\n\nEnabled by default. Block quotes can be nested and contain other block elements.\n\n> This is a block quote.\n>\n> > Nested quote.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.Citation","page":"API Reference","title":"CommonMark.Citation","text":"Citation reference. Build with Node(Citation, \"id\"; brackets=false).\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.CitationRule","page":"API Reference","title":"CommonMark.CitationRule","text":"CitationRule()\n\nParse citation references using @key or [@key] syntax.\n\nNot enabled by default. Citations can be bare (@smith2020) or bracketed ([@smith2020]). Requires a bibliography to be configured for rendering.\n\nAccording to @smith2020, this is true.\n\nMultiple citations: [@smith2020; @jones2021]\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.Code","page":"API Reference","title":"CommonMark.Code","text":"Inline code span. Build with Node(Code, \"code string\").\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.CodeBlock","page":"API Reference","title":"CommonMark.CodeBlock","text":"Code block (fenced or indented). Build with Node(CodeBlock, code; info=\"language\").\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.DisplayMath","page":"API Reference","title":"CommonMark.DisplayMath","text":"Display math block. Build with Node(DisplayMath, \"expression\").\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.Document","page":"API Reference","title":"CommonMark.Document","text":"Root container for a CommonMark AST. All documents start with this node.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.DollarMathRule","page":"API Reference","title":"CommonMark.DollarMathRule","text":"DollarMathRule()\n\nParse LaTeX math with dollar sign delimiters (without backticks).\n\nNot enabled by default. Inline math uses $...$, display math uses $$...$$.\n\nInline: $E = mc^2$\n\nDisplay:\n$$\n\\int_0^\\infty e^{-x^2} dx\n$$\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.Emph","page":"API Reference","title":"CommonMark.Emph","text":"Emphasis (italic). Contains inline children.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.FencedCodeBlockRule","page":"API Reference","title":"CommonMark.FencedCodeBlockRule","text":"FencedCodeBlockRule()\n\nParse fenced code blocks (triple backticks or tildes).\n\nEnabled by default. Supports optional language identifier.\n\n```julia\nprintln(\"Hello\")\n```\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.FencedDiv","page":"API Reference","title":"CommonMark.FencedDiv","text":"Generic div container. Build with Node(FencedDiv, children...; class=\"name\", id=\"id\").\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.FencedDivRule","page":"API Reference","title":"CommonMark.FencedDivRule","text":"FencedDivRule()\n\nParse Pandoc-style fenced divs (::: class blocks).\n\nNot enabled by default. Creates generic container elements with CSS classes. Divs can be nested by using more colons.\n\n::: warning\nThis is a warning div.\n:::\n\n:::: outer\n::: inner\nNested divs.\n:::\n::::\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.FootnoteDefinition","page":"API Reference","title":"CommonMark.FootnoteDefinition","text":"Footnote definition block. Build with Node(FootnoteDefinition, \"id\", children...).\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.FootnoteLink","page":"API Reference","title":"CommonMark.FootnoteLink","text":"Footnote reference link. Build with Node(FootnoteLink, \"id\").\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.FootnoteRule","page":"API Reference","title":"CommonMark.FootnoteRule","text":"FootnoteRule()\n\nParse footnote definitions and references.\n\nNot enabled by default. Define footnotes with [^id]: and reference with [^id].\n\nHere is a footnote reference[^1].\n\n[^1]: This is the footnote content.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.FrontMatterRule","page":"API Reference","title":"CommonMark.FrontMatterRule","text":"FrontMatterRule(; yaml=identity, toml=identity, json=identity)\n\nParse YAML, TOML, or JSON front matter at document start.\n\nNot enabled by default. Front matter is delimited by --- (YAML), +++ (TOML), or ;;; (JSON). Pass parser functions for each format.\n\n---\ntitle: My Document\nauthor: Jane Doe\n---\n\nDocument content here.\n\nUse frontmatter to extract the parsed data.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.GitHubAlert","page":"API Reference","title":"CommonMark.GitHubAlert","text":"GitHub-style alert. Build with Node(GitHubAlert, category, children...; title=\"optional\"). Categories: note, tip, important, warning, caution.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.GitHubAlertRule","page":"API Reference","title":"CommonMark.GitHubAlertRule","text":"GitHubAlertRule()\n\nParse GitHub-style alert blockquotes.\n\nNot enabled by default. Converts blockquotes starting with [!TYPE] into styled alert boxes. Supported types: NOTE, TIP, IMPORTANT, WARNING, CAUTION.\n\n> [!NOTE]\n> This is a note alert.\n\n> [!WARNING]\n> This is a warning alert.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.Heading","page":"API Reference","title":"CommonMark.Heading","text":"Heading with level 1-6. Build with Node(Heading, level, children...).\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.HtmlBlock","page":"API Reference","title":"CommonMark.HtmlBlock","text":"Raw HTML block. Build with Node(HtmlBlock, html_string).\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.HtmlBlockRule","page":"API Reference","title":"CommonMark.HtmlBlockRule","text":"HtmlBlockRule()\n\nParse raw HTML blocks.\n\nEnabled by default. Recognizes common HTML tags and passes them through unchanged.\n\n<div class=\"warning\">\n  <p>Raw HTML content</p>\n</div>\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.HtmlEntityRule","page":"API Reference","title":"CommonMark.HtmlEntityRule","text":"HtmlEntityRule()\n\nParse HTML entities (&amp;, &#123;, &#x7B;).\n\nEnabled by default. Converts entities to their Unicode equivalents.\n\n&copy; &amp; &#60; &#x3C;\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.HtmlInline","page":"API Reference","title":"CommonMark.HtmlInline","text":"Raw inline HTML. Build with Node(HtmlInline, \"<tag>\").\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.HtmlInlineRule","page":"API Reference","title":"CommonMark.HtmlInlineRule","text":"HtmlInlineRule()\n\nParse inline HTML tags.\n\nEnabled by default. Passes through raw HTML tags unchanged.\n\nThis has <em>inline HTML</em> tags.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.Image","page":"API Reference","title":"CommonMark.Image","text":"Image. Build with Node(Image; dest=\"url\", alt=\"text\", title=\"optional\").\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.ImageRule","page":"API Reference","title":"CommonMark.ImageRule","text":"ImageRule()\n\nParse inline and reference images.\n\nEnabled by default. Same syntax as links but prefixed with !.\n\n![alt text](image.png)\n![alt text][ref]\n\n[ref]: image.png\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.IndentedCodeBlockRule","page":"API Reference","title":"CommonMark.IndentedCodeBlockRule","text":"IndentedCodeBlockRule()\n\nParse indented code blocks (4 spaces or 1 tab).\n\nEnabled by default.\n\n    code here\n    more code\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.InlineCodeRule","page":"API Reference","title":"CommonMark.InlineCodeRule","text":"InlineCodeRule()\n\nParse inline code spans (backtick-delimited).\n\nEnabled by default. Uses matching backtick counts for nesting.\n\nUse `code` inline or `` `backticks` `` inside.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.Item","page":"API Reference","title":"CommonMark.Item","text":"List item. Usually created as a child of List.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.LaTeXBlock","page":"API Reference","title":"CommonMark.LaTeXBlock","text":"Raw LaTeX block content. Build with Node(LaTeXBlock, \"\\\\begin{...}\").\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.LaTeXInline","page":"API Reference","title":"CommonMark.LaTeXInline","text":"Raw LaTeX inline content. Build with Node(LaTeXInline, \"\\\\command\").\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.LineBreak","page":"API Reference","title":"CommonMark.LineBreak","text":"Hard line break (rendered as <br> in HTML).\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.Link","page":"API Reference","title":"CommonMark.Link","text":"Hyperlink. Build with Node(Link, children...; dest=\"url\", title=\"optional\").\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.LinkRule","page":"API Reference","title":"CommonMark.LinkRule","text":"LinkRule()\n\nParse inline and reference links.\n\nEnabled by default. Supports both inline [text](url) and reference [text][ref] styles.\n\n[inline link](https://example.com)\n[reference link][ref]\n\n[ref]: https://example.com\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.List","page":"API Reference","title":"CommonMark.List","text":"Bullet or ordered list. Build with Node(List, items...; ordered=false, start=1, tight=true).\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.ListItemRule","page":"API Reference","title":"CommonMark.ListItemRule","text":"ListItemRule()\n\nParse list items (bulleted and ordered lists).\n\nEnabled by default. Supports -, +, * for bullets and 1., 1) for ordered.\n\n- Item one\n- Item two\n\n1. First\n2. Second\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.Math","page":"API Reference","title":"CommonMark.Math","text":"Inline math expression. Build with Node(Math, \"expression\").\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.MathRule","page":"API Reference","title":"CommonMark.MathRule","text":"MathRule()\n\nParse LaTeX math in double-backtick code spans and fenced code blocks.\n\nNot enabled by default. Inline math uses double backticks (``...``), display math uses math ``` fenced blocks.\n\nInline: ``E = mc^2``\n\nDisplay:\n```math\n\\int_0^\\infty e^{-x^2} dx\n```\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.Node-Tuple{AbstractDict}","page":"API Reference","title":"CommonMark.Node","text":"Node(data::AbstractDict) -> Node\n\nConstruct a CommonMark AST from a Pandoc AST JSON dictionary.\n\nThe input should be a parsed JSON dictionary with \"pandoc-api-version\", \"meta\", and \"blocks\" keys. Use JSON.parse(str) to convert a JSON string first.\n\nInverse of json(Dict, ast).\n\nExamples\n\nusing JSON\ndata = JSON.parse(json_string)\nast = Node(data)\n\n# Round-trip:\nast2 = Node(json(Dict, ast))\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.Node-Tuple{Type{CommonMark.ReferenceDefinition}}","page":"API Reference","title":"CommonMark.Node","text":"Reference definition. Build with Node(ReferenceDefinition; label, dest, title=\"\").\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.Node-Tuple{Type{CommonMark.ReferenceImage}, Vararg{Any}}","page":"API Reference","title":"CommonMark.Node","text":"Reference-style image. Build with Node(ReferenceImage, children...; dest, label, title=\"\", style=:full).\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.Node-Tuple{Type{CommonMark.ReferenceLink}, Vararg{Any}}","page":"API Reference","title":"CommonMark.Node","text":"Reference-style link. Build with Node(ReferenceLink, children...; dest, label, title=\"\", style=:full).\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.Node-Tuple{Type{CommonMark.UnresolvedReference}, Vararg{Any}}","page":"API Reference","title":"CommonMark.Node","text":"Unresolved reference. Build with Node(UnresolvedReference, children...; label, style=:shortcut, image=false).\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.Paragraph","page":"API Reference","title":"CommonMark.Paragraph","text":"Text paragraph containing inline content.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.Parser","page":"API Reference","title":"CommonMark.Parser","text":"Parser()\n\nCreate a CommonMark parser with default block and inline rules enabled.\n\nThe parser can be called directly on a string to produce an AST, which can then be rendered to various output formats using html, latex, term, markdown, notebook, or typst.\n\nExamples\n\np = Parser()\nast = p(\"# Hello\\n\\nWorld\")\nhtml(ast)  # \"<h1>Hello</h1>\\n<p>World</p>\\n\"\n\nUse enable! and disable! to customize which rules are active.\n\np = Parser()\nenable!(p, TableRule())\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.RawContentRule","page":"API Reference","title":"CommonMark.RawContentRule","text":"RawContentRule(; formats...)\n\nParse format-specific raw content blocks.\n\nNot enabled by default. Uses content=format syntax for inline and fenced blocks with {=format} for blocks. The _inline or _block suffix is added automatically based on context.\n\n`<span>html</span>`{=html}\n\n\n{=latex} \\textbf{LaTeX content}\n\n\n\nDefault formats: html, latex, typst.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.ReferenceLinkRule","page":"API Reference","title":"CommonMark.ReferenceLinkRule","text":"ReferenceLinkRule()\n\nPreserve reference link style in the AST.\n\nNot enabled by default. By default, reference links are resolved to inline links during parsing. This rule preserves the original reference style (full, collapsed, or shortcut) for roundtrip rendering.\n\n[full style][ref]\n[collapsed style][]\n[shortcut style]\n\n[ref]: https://example.com\n\nAST Node Types\n\nWhen enabled, this rule produces these node types:\n\nReferenceLink / ReferenceImage - resolved reference links with fields:\ndestination::String - the URL\ntitle::String - optional title\nlabel::String - the reference label\nstyle::Symbol - :full, :collapsed, or :shortcut\nReferenceDefinition - block node for [label]: url definitions\nUnresolvedReference - references with undefined labels:\nlabel::String - the reference label\nstyle::Symbol - :full, :collapsed, or :shortcut\nimage::Bool - true for ![...] syntax\n\nFinding Undefined References\n\nThe UnresolvedReference type enables programmatic detection of broken links:\n\np = Parser()\nenable!(p, ReferenceLinkRule())\nast = p(markdown_text)\n\nundefined = [n.t for (n, entering) in ast\n             if entering && n.t isa CommonMark.UnresolvedReference]\n# Each has: label, style (:full/:collapsed/:shortcut), image (Bool)\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.SetextHeadingRule","page":"API Reference","title":"CommonMark.SetextHeadingRule","text":"SetextHeadingRule()\n\nParse setext-style headings (underlined with = or -).\n\nEnabled by default. Only supports levels 1 and 2.\n\nHeading 1\n=========\n\nHeading 2\n---------\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.SoftBreak","page":"API Reference","title":"CommonMark.SoftBreak","text":"Soft line break (rendered as space or newline depending on output format).\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.Strikethrough","page":"API Reference","title":"CommonMark.Strikethrough","text":"Strikethrough text. Contains inline children.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.StrikethroughRule","page":"API Reference","title":"CommonMark.StrikethroughRule","text":"StrikethroughRule()\n\nParse strikethrough text (~~deleted~~).\n\nNot enabled by default. Uses double tildes to mark deleted text.\n\n~~This text is struck through.~~\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.Strong","page":"API Reference","title":"CommonMark.Strong","text":"Strong emphasis (bold). Contains inline children.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.Subscript","page":"API Reference","title":"CommonMark.Subscript","text":"Subscript text. Contains inline children.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.SubscriptRule","page":"API Reference","title":"CommonMark.SubscriptRule","text":"SubscriptRule()\n\nParse subscript text (~subscript~).\n\nNot enabled by default. Uses single tildes to mark subscript text.\n\nH~2~O renders as H₂O\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.Superscript","page":"API Reference","title":"CommonMark.Superscript","text":"Superscript text. Contains inline children.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.SuperscriptRule","page":"API Reference","title":"CommonMark.SuperscriptRule","text":"SuperscriptRule()\n\nParse superscript text (^superscript^).\n\nNot enabled by default. Uses carets to mark superscript text.\n\nx^2^ renders as x²\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.Table","page":"API Reference","title":"CommonMark.Table","text":"Table container. Build with Node(Table, header, body_rows...; align=[:left, :center, :right]).\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.TableBody","page":"API Reference","title":"CommonMark.TableBody","text":"Table body section containing data rows.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.TableCell","page":"API Reference","title":"CommonMark.TableCell","text":"Table cell. Build with Node(TableCell, children...; align=:left, header=false, column=1).\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.TableHeader","page":"API Reference","title":"CommonMark.TableHeader","text":"Table header section containing one row.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.TableRow","page":"API Reference","title":"CommonMark.TableRow","text":"Table row containing cells.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.TableRule","page":"API Reference","title":"CommonMark.TableRule","text":"TableRule()\n\nParse GitHub Flavored Markdown pipe tables.\n\nNot enabled by default. Tables use | to separate columns and require a header separator row.\n\n| Header 1 | Header 2 |\n|----------|----------|\n| Cell 1   | Cell 2   |\n\nAlignment can be specified with : in the separator row:\n\n:--- left align\n:---: center align\n---: right align\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.TaskItem","page":"API Reference","title":"CommonMark.TaskItem","text":"Task list item with checkbox. Build with Node(TaskItem, children...; checked=false).\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.TaskListRule","page":"API Reference","title":"CommonMark.TaskListRule","text":"TaskListRule()\n\nParse GitHub-style task list items.\n\nNot enabled by default. Converts list items starting with [ ] or [x] into interactive checkboxes in HTML output.\n\n- [ ] Unchecked item\n- [x] Checked item\n- Regular item\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.Text","page":"API Reference","title":"CommonMark.Text","text":"Plain text content.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.ThematicBreak","page":"API Reference","title":"CommonMark.ThematicBreak","text":"Horizontal rule/thematic break. Build with Node(ThematicBreak).\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.ThematicBreakRule","page":"API Reference","title":"CommonMark.ThematicBreakRule","text":"ThematicBreakRule()\n\nParse thematic breaks (horizontal rules).\n\nEnabled by default. Requires 3+ of *, -, or _ characters.\n\n***\n\n---\n\n___\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.TypographyRule","page":"API Reference","title":"CommonMark.TypographyRule","text":"TypographyRule(; double_quotes=true, single_quotes=true, ellipses=true, dashes=true)\n\nConvert ASCII punctuation to typographic equivalents.\n\nNot enabled by default. Converts:\n\n\"...\" to \"...\" (curly double quotes)\n'...' to '...' (curly single quotes)\n... to … (ellipsis)\n-- to – and --- to — (en/em dashes)\n\nDisable specific conversions with keyword arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.TypstBlock","page":"API Reference","title":"CommonMark.TypstBlock","text":"Raw Typst block content. Build with Node(TypstBlock, \"#figure[]\").\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.TypstInline","page":"API Reference","title":"CommonMark.TypstInline","text":"Raw Typst inline content. Build with Node(TypstInline, \"#command\").\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.UnderscoreEmphasisRule","page":"API Reference","title":"CommonMark.UnderscoreEmphasisRule","text":"UnderscoreEmphasisRule()\n\nParse emphasis using underscores (_ and __).\n\nEnabled by default. Single for italic, double for bold.\n\n_italic_ and __bold__ and ___both___\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.append_child-Tuple{CommonMark.Node, CommonMark.Node}","page":"API Reference","title":"CommonMark.append_child","text":"append_child(parent::Node, child::Node)\n\nAdd child as the last child of parent. Unlinks child from any previous location.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.ast_equal-Tuple{CommonMark.Node, CommonMark.Node}","page":"API Reference","title":"CommonMark.ast_equal","text":"ast_equal(a::Node, b::Node)\n\nCompare two AST nodes for structural equality. Ignores source positions and parser state, comparing only the semantic content: container types, literals, and tree structure.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.available_columns-Tuple{CommonMark.Writer{CommonMark.Term}}","page":"API Reference","title":"CommonMark.available_columns","text":"Given the current indent of the renderer we check to see how much space is left on the current line.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.container_equal-Union{Tuple{T}, Tuple{T, T}} where T<:CommonMark.AbstractContainer","page":"API Reference","title":"CommonMark.container_equal","text":"container_equal(a::AbstractContainer, b::AbstractContainer)\n\nCompare two container types for equality, checking type and all fields.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.default_transform-Tuple{Any, CommonMark.AbstractContainer, Any, Any, Any}","page":"API Reference","title":"CommonMark.default_transform","text":"default_transform(mime, container, node, entering, writer)\n\nDefault transform - passes through node unchanged. Users can define methods dispatching on container types to transform nodes.\n\nExample\n\nfunction my_transform(::MIME\"text/html\", link::Link, node, entering, writer)\n    if entering\n        dest = transform_url(link.destination)\n        (Node(Link; dest = dest, title = link.title), entering)\n    else\n        (node, entering)\n    end\nend\nmy_transform(mime, ::AbstractContainer, node, entering, writer) =\n    (node, entering)\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.disable!-Tuple{CommonMark.AbstractParser, Union{Tuple, Vector}}","page":"API Reference","title":"CommonMark.disable!","text":"disable!(parser, rule)\ndisable!(parser, rules)\n\nDisable a parsing rule or collection of rules from the parser.\n\nThis removes the specified rules and re-enables all remaining rules. Useful for removing default CommonMark behavior.\n\nReturns the parser for method chaining.\n\nExamples\n\np = Parser()\ndisable!(p, SetextHeadingRule())  # Only allow ATX-style headings\ndisable!(p, [HtmlBlockRule(), HtmlInlineRule()])  # Disable raw HTML\n\nSee also: enable!, Parser\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.enable!-Tuple{CommonMark.AbstractParser, Any}","page":"API Reference","title":"CommonMark.enable!","text":"enable!(parser, rule)\nenable!(parser, rules)\n\nEnable a parsing rule or collection of rules in the parser.\n\nRules can be core CommonMark rules (e.g., AtxHeadingRule) or extension rules (e.g., TableRule, AdmonitionRule).\n\nReturns the parser for method chaining.\n\nExamples\n\np = Parser()\nenable!(p, TableRule())\nenable!(p, [FootnoteRule(), AdmonitionRule()])\n\nSee also: disable!, Parser\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.finalize_literal!-Tuple{CommonMark.Node}","page":"API Reference","title":"CommonMark.finalize_literal!","text":"Finalize literal from buffer, converting IOBuffer to String.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.frontmatter-Tuple{CommonMark.Node}","page":"API Reference","title":"CommonMark.frontmatter","text":"frontmatter(ast::Node) -> Dict{String,Any}\n\nExtract front matter data from a parsed document.\n\nReturns an empty dictionary if no front matter is present. Requires FrontMatterRule to be enabled during parsing. Supports YAML (---), TOML (+++), and JSON (;;;) delimiters.\n\nExamples\n\np = Parser()\nenable!(p, FrontMatterRule(yaml=YAML.load))\nast = p(\"\"\"\n---\ntitle: My Document\nauthor: Jane Doe\n---\n# Content\n\"\"\")\nfrontmatter(ast)  # Dict(\"title\" => \"My Document\", \"author\" => \"Jane Doe\")\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.getmeta-Tuple{CommonMark.Node, Any, Any}","page":"API Reference","title":"CommonMark.getmeta","text":"Get meta value without allocating if meta is nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.hasmeta-Tuple{CommonMark.Node, Any}","page":"API Reference","title":"CommonMark.hasmeta","text":"Check if meta has key without allocating if meta is nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.html-Tuple","page":"API Reference","title":"CommonMark.html","text":"html(ast::Node) -> String\nhtml(filename::String, ast::Node)\nhtml(io::IO, ast::Node)\n\nRender a CommonMark AST to HTML.\n\nKeyword Arguments\n\nsoftbreak::String = \"\\n\": String to use for soft line breaks\nsafe::Bool = false: Escape potentially unsafe HTML content\nsourcepos::Bool = false: Include source position data attributes\n\nExamples\n\np = Parser()\nast = p(\"# Hello\\n\\nWorld\")\nhtml(ast)  # \"<h1>Hello</h1>\\n<p>World</p>\\n\"\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.insert_after-Tuple{CommonMark.Node, CommonMark.Node}","page":"API Reference","title":"CommonMark.insert_after","text":"insert_after(node::Node, sibling::Node)\n\nInsert sibling immediately after node in the tree.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.insert_before-Tuple{CommonMark.Node, CommonMark.Node}","page":"API Reference","title":"CommonMark.insert_before","text":"insert_before(node::Node, sibling::Node)\n\nInsert sibling immediately before node in the tree.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.isnull-Tuple{CommonMark.Node}","page":"API Reference","title":"CommonMark.isnull","text":"isnull(node::Node) -> Bool\n\nCheck if a node is the null node (empty reference).\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.json-Tuple","page":"API Reference","title":"CommonMark.json","text":"json(ast::Node; dicttype=Dict) -> String\njson(filename::String, ast::Node; dicttype=Dict)\njson(io::IO, ast::Node; dicttype=Dict)\njson(::Type{<:AbstractDict}, ast::Node) -> AbstractDict\n\nRender a CommonMark AST to Pandoc AST JSON format.\n\nThe output can be piped to pandoc -f json -t <format> to convert to any format Pandoc supports (docx, epub, rst, asciidoc, etc.).\n\nThe dicttype keyword argument controls the dictionary type used internally. Use OrderedCollections.OrderedDict for deterministic key ordering.\n\nPass a dict type as the first argument to return the dict directly without JSON string serialization: json(Dict, ast).\n\nExamples\n\np = Parser()\nast = p(\"# Hello\\n\\nWorld\")\noutput = json(ast)\n# Use with: echo $output | pandoc -f json -t docx -o out.docx\n\n# Get dict directly (no JSON string):\nd = json(Dict, ast)\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.latex-Tuple","page":"API Reference","title":"CommonMark.latex","text":"latex(ast::Node) -> String\nlatex(filename::String, ast::Node)\nlatex(io::IO, ast::Node)\n\nRender a CommonMark AST to LaTeX.\n\nExamples\n\np = Parser()\nast = p(\"# Hello\\n\\nWorld\")\nlatex(ast)  # \"\\\\section{Hello}\\n\\nWorld\\n\"\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.literal_width-Tuple{CommonMark.Node}","page":"API Reference","title":"CommonMark.literal_width","text":"What is the width of the literal text stored in node and all of it's child nodes. Used to determine alignment for rendering nodes such as centered.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.markdown-Tuple","page":"API Reference","title":"CommonMark.markdown","text":"markdown(ast::Node) -> String\nmarkdown(filename::String, ast::Node)\nmarkdown(io::IO, ast::Node)\n\nRender a CommonMark AST back to Markdown text.\n\nUseful for normalizing Markdown formatting or for roundtrip testing. Output uses opinionated formatting with no trailing whitespace.\n\nExamples\n\np = Parser()\nast = p(\"# Hello\\n\\nWorld\")\nmarkdown(ast)  # \"# Hello\\n\\nWorld\\n\"\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.mergemeta!-Tuple{CommonMark.Node, AbstractDict}","page":"API Reference","title":"CommonMark.mergemeta!","text":"Merge dict into meta, initializing if needed.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.notebook-Tuple","page":"API Reference","title":"CommonMark.notebook","text":"notebook(ast::Node) -> String\nnotebook(filename::String, ast::Node)\nnotebook(io::IO, ast::Node)\n\nRender a CommonMark AST to a Jupyter notebook (.ipynb format).\n\nCode blocks are converted to code cells, and other content becomes Markdown cells.\n\nExamples\n\np = Parser()\nast = p(\"# Title\\n\\n```julia\\nprintln(\\\"Hello\\\")\\n```\")\nnotebook(\"output.ipynb\", ast)\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.prepend_child-Tuple{CommonMark.Node, CommonMark.Node}","page":"API Reference","title":"CommonMark.prepend_child","text":"prepend_child(parent::Node, child::Node)\n\nAdd child as the first child of parent. Unlinks child from any previous location.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.print_literal-Tuple{CommonMark.Writer{CommonMark.Term}, Vararg{Any}}","page":"API Reference","title":"CommonMark.print_literal","text":"Literal printing of a of parts. Behaviour depends on when .wrap is active at the moment, which is set in Paragraph rendering.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.print_margin-Tuple{CommonMark.Writer}","page":"API Reference","title":"CommonMark.print_margin","text":"Print out all the current segments present in the margin buffer.\n\nEach time a segment gets printed it's count is reduced. When a segment has a count of zero it won't be printed and instead spaces equal to it's width are printed. For persistent printing a count of -1 should be used.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.push_margin!","page":"API Reference","title":"CommonMark.push_margin!","text":"Adds a new segment to the margin buffer. This segment is persistent and thus will print on every margin print.\n\n\n\n\n\n","category":"function"},{"location":"api/#CommonMark.push_margin!-2","page":"API Reference","title":"CommonMark.push_margin!","text":"Adds a new segment to the margin buffer, but will only print out for the given number of count calls to print_margin. After count calls it will instead print out spaces equal to the width of text.\n\n\n\n\n\n","category":"function"},{"location":"api/#CommonMark.push_margin!-Tuple{CommonMark.Writer, Integer, AbstractString, AbstractString}","page":"API Reference","title":"CommonMark.push_margin!","text":"Adds new segmant to the margin buffer. count determines how many time initial is printed. After that, the width of rest is printed instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.setmeta!-Tuple{CommonMark.Node, Any, Any}","page":"API Reference","title":"CommonMark.setmeta!","text":"Set meta value, initializing dict if needed.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.term-Tuple","page":"API Reference","title":"CommonMark.term","text":"term(ast::Node) -> String\nterm(filename::String, ast::Node)\nterm(io::IO, ast::Node)\n\nRender a CommonMark AST for terminal display with ANSI formatting.\n\nIncludes colored syntax highlighting for code blocks when a highlighter is configured.\n\nExamples\n\np = Parser()\nast = p(\"# Hello\\n\\n**World**\")\nterm(ast)  # Returns ANSI-formatted string\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.text-Tuple{AbstractString}","page":"API Reference","title":"CommonMark.text","text":"text(s::AbstractString) -> Node\n\nCreate a Text node containing the given string.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.typst-Tuple","page":"API Reference","title":"CommonMark.typst","text":"typst(ast::Node) -> String\ntypst(filename::String, ast::Node)\ntypst(io::IO, ast::Node)\n\nRender a CommonMark AST to Typst markup.\n\nExamples\n\np = Parser()\nast = p(\"# Hello\\n\\nWorld\")\ntypst(ast)\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.unlink-Tuple{CommonMark.Node}","page":"API Reference","title":"CommonMark.unlink","text":"unlink(node::Node)\n\nRemove node from its parent, updating sibling links. Safe to call on unlinked nodes.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.@cm_str","page":"API Reference","title":"CommonMark.@cm_str","text":"cm\"\"\n\nA string macro for markdown text that implements standard string interpolation. Returns a parsed markdown AST with the values of the interpolation expressions embedded in the AST.\n\nvalue = \"interpolated\"\ncm\"Some *$(value)* text.\"\n\nThe default syntax rules used for parsing are:\n\nAdmonitionRule\nAttributeRule\nAutoIdentifierRule\nCitationRule\nFootnoteRule\nMathRule\nRawContentRule\nTableRule\nTypographyRule\n\nwhich matches closely with the default syntax supported in Markdown.@md_str.\n\ninfo: Info\nThe DollarMathRule is not enabled since it conflicts with the interpolation syntax. Use double backticks and math language literal blocks for maths that is provided by the MathRule.\n\nA custom Parser can be invoked when using cm\"\" by providing a suffix to the macro call, for example:\n\nmore = \"more\"\ncm\"Some **$(uppercase(more))** text.\"none\n\nwhere the suffixed none will invoke a basic Parser with no additional syntax rules enabled!. To use your own custom parser, for example to only enable the TypographyRule, you can suffix the call with a named function from the current module's global scope that returns the Parser object with the required rules enabled:\n\ncustom() = enable!(Parser(), TypographyRule())\n\nIt can then be used as\n\nstr = \"custom\"\ncm\"A '$(titlecase(str))' parser...\"custom\n\n\n\n\n\n","category":"macro"},{"location":"core/#Core-Rules","page":"Core Rules","title":"Core Rules","text":"These rules are enabled by default in Parser() and implement the CommonMark specification. They cover the standard markdown syntax that most users expect.\n\nusing CommonMark\nparser = Parser()\nnothing # hide","category":"section"},{"location":"core/#Block-Rules","page":"Core Rules","title":"Block Rules","text":"Block rules handle document structure: headings, paragraphs, lists, code blocks, and other elements that occupy their own lines.","category":"section"},{"location":"core/#ATX-Headings","page":"Core Rules","title":"ATX Headings","text":"Headings prefixed with # characters. Supports levels 1-6.\n\nast = parser(\"# Heading 1\\n## Heading 2\\n### Heading 3\")\nhtml(ast)","category":"section"},{"location":"core/#Setext-Headings","page":"Core Rules","title":"Setext Headings","text":"Headings underlined with = or -. Only supports levels 1 and 2.\n\nast = parser(\"Heading 1\\n=========\\n\\nHeading 2\\n---------\")\nhtml(ast)","category":"section"},{"location":"core/#Block-Quotes","page":"Core Rules","title":"Block Quotes","text":"Quoted text prefixed with >. Can be nested and contain other block elements.\n\nast = parser(\"> This is a block quote.\\n> It can span multiple lines.\")\nhtml(ast)","category":"section"},{"location":"core/#Lists","page":"Core Rules","title":"Lists","text":"Unordered lists use -, +, or * as markers:\n\nast = parser(\"- Item one\\n- Item two\\n- Item three\")\nhtml(ast)\n\nOrdered lists use numbers followed by . or ):\n\nast = parser(\"1. First item\\n2. Second item\\n3. Third item\")\nhtml(ast)\n\nLists can be nested by indenting items, and can contain multiple paragraphs or other block elements.","category":"section"},{"location":"core/#Fenced-Code-Blocks","page":"Core Rules","title":"Fenced Code Blocks","text":"Code blocks delimited by triple backticks or tildes. An optional info string specifies the language for syntax highlighting.\n\nast = parser(\"\"\"\n```julia\nprintln(\"Hello, World!\")\n```\n\"\"\")\nhtml(ast)","category":"section"},{"location":"core/#Indented-Code-Blocks","page":"Core Rules","title":"Indented Code Blocks","text":"Code indented by at least 4 spaces. No language info string is possible.\n\nast = parser(\"    function hello()\\n        println(\\\"Hello\\\")\\n    end\")\nhtml(ast)","category":"section"},{"location":"core/#HTML-Blocks","page":"Core Rules","title":"HTML Blocks","text":"Raw HTML that passes through unchanged. Useful for embedding content that markdown can't express.\n\nast = parser(\"<div class=\\\"custom\\\">\\n  Raw HTML content.\\n</div>\")\nhtml(ast)","category":"section"},{"location":"core/#Thematic-Breaks","page":"Core Rules","title":"Thematic Breaks","text":"Horizontal rules created with three or more -, *, or _ characters.\n\nast = parser(\"Above\\n\\n---\\n\\nBelow\")\nhtml(ast)","category":"section"},{"location":"core/#Inline-Rules","page":"Core Rules","title":"Inline Rules","text":"Inline rules handle formatting within paragraphs: emphasis, links, code spans, and other elements that flow with text.","category":"section"},{"location":"core/#Emphasis","page":"Core Rules","title":"Emphasis","text":"Asterisks and underscores create emphasis. Single delimiters produce <em>, double delimiters produce <strong>.\n\nast = parser(\"*italic* and **bold** and ***both***\")\nhtml(ast)\n\nast = parser(\"_italic_ and __bold__ and ___both___\")\nhtml(ast)","category":"section"},{"location":"core/#Inline-Code","page":"Core Rules","title":"Inline Code","text":"Backticks create code spans. Use multiple backticks to include literal backticks.\n\nast = parser(\"Use `code` for inline code.\")\nhtml(ast)","category":"section"},{"location":"core/#Links","page":"Core Rules","title":"Links","text":"Inline links with the URL in parentheses, or reference links defined elsewhere.\n\nast = parser(\"[inline link](https://example.com)\")\nhtml(ast)\n\nReference-style links separate the URL from the text, useful for keeping paragraphs readable or reusing the same URL multiple times.","category":"section"},{"location":"core/#Images","page":"Core Rules","title":"Images","text":"Same syntax as links but prefixed with !. The link text becomes alt text.\n\nast = parser(\"![alt text](image.png)\")\nhtml(ast)","category":"section"},{"location":"core/#Autolinks","page":"Core Rules","title":"Autolinks","text":"URLs and email addresses in angle brackets become clickable links automatically.\n\nast = parser(\"<https://example.com>\")\nhtml(ast)","category":"section"},{"location":"core/#HTML-Inline","page":"Core Rules","title":"HTML Inline","text":"Raw HTML tags within paragraphs pass through unchanged.\n\nast = parser(\"This has <em>inline HTML</em> content.\")\nhtml(ast)","category":"section"},{"location":"core/#HTML-Entities","page":"Core Rules","title":"HTML Entities","text":"Named and numeric HTML entities are decoded.\n\nast = parser(\"&amp; &copy; &mdash;\")\nhtml(ast)","category":"section"},{"location":"core/#Disabling-Default-Rules","page":"Core Rules","title":"Disabling Default Rules","text":"Use disable! to turn off rules you don't want. This is useful for stricter parsing or when certain syntax conflicts with your content.\n\np = Parser()\ndisable!(p, SetextHeadingRule())  # Only ATX headings\ndisable!(p, [HtmlBlockRule(), HtmlInlineRule()])  # No raw HTML\nnothing # hide","category":"section"},{"location":"developing/#Developing-Extensions","page":"Developing Extensions","title":"Developing Extensions","text":"warning: Internal API\nThis documents internal interfaces not covered by semantic versioning. These APIs may change between any versions without notice.\n\nThis page documents how to create custom parsing rules for CommonMark.jl. An extension consists of three parts: AST node types, parsing rules, and writer functions.\n\nusing CommonMark\nnothing # hide","category":"section"},{"location":"developing/#AST-Nodes","page":"Developing Extensions","title":"AST Nodes","text":"","category":"section"},{"location":"developing/#Type-Hierarchy","page":"Developing Extensions","title":"Type Hierarchy","text":"All node types inherit from AbstractContainer:\n\nabstract type AbstractContainer end\nabstract type AbstractBlock <: AbstractContainer end   # Block-level elements\nabstract type AbstractInline <: AbstractContainer end  # Inline elements\n\nDefine your node type as a struct:\n\nstruct MyBlock <: AbstractBlock\n    info::String  # Store any data your extension needs\nend\n\nstruct MyInline <: AbstractInline end","category":"section"},{"location":"developing/#The-Node-Struct","page":"Developing Extensions","title":"The Node Struct","text":"Nodes wrap your container type in a tree structure:\n\nmutable struct Node\n    t::AbstractContainer      # Your container type (MyBlock, MyInline, etc.)\n    parent::Node              # Parent node\n    first_child::Node         # First child\n    last_child::Node          # Last child\n    prv::Node                 # Previous sibling\n    nxt::Node                 # Next sibling\n    sourcepos::SourcePos      # Source position ((start_line, start_col), (end_line, end_col))\n    literal::String           # Text content (for leaf nodes)\n    meta::Dict{String,Any}    # Arbitrary metadata\nend\n\nUse isnull(node) to check for null references (rather than checking against nothing).","category":"section"},{"location":"developing/#Container-Behavior-Methods","page":"Developing Extensions","title":"Container Behavior Methods","text":"Define these methods to control how your node participates in parsing:\n\n# Can this node contain children? Default: false\nis_container(::MyBlock) = true\n\n# Does this block accept raw text lines? (like code blocks)\naccepts_lines(::MyBlock) = false\n\n# Which child types are allowed? Default allows most types.\ncan_contain(::MyBlock, child) = !(child isa Item)\n\n# Called when the block is closed. Default: nothing\nfinalize(::MyBlock, parser::Parser, node::Node) = nothing\n\n# Called to check if this block continues on the next line.\n# Return: 0 = continue, 1 = close block, 2 = close and skip line\nfunction continue_(::MyBlock, parser::Parser, node::Node)\n    if parser.indent >= 4\n        advance_offset(parser, 4, true)\n        return 0  # Continue this block\n    elseif parser.blank\n        advance_next_nonspace(parser)\n        return 0\n    else\n        return 1  # Close this block\n    end\nend","category":"section"},{"location":"developing/#Rule-Interface","page":"Developing Extensions","title":"Rule Interface","text":"","category":"section"},{"location":"developing/#The-Rule-Struct","page":"Developing Extensions","title":"The Rule Struct","text":"Rules wrap parsing functions with metadata:\n\nstruct Rule\n    fn::Function       # The parsing function\n    priority::Float64  # Lower priority runs first\n    triggers::String   # Trigger characters (empty = all positions)\nend\n\nRule(fn, priority, triggers = \"\")\n\nCreate rules with do-block syntax:\n\nblock_rule(::MyRule) = Rule(0.5, \"!\") do parser, container\n    # Parse logic here\n    return 0\nend","category":"section"},{"location":"developing/#Rule-Hooks","page":"Developing Extensions","title":"Rule Hooks","text":"Define these methods on your rule type to register parsing functions:\n\nHook Purpose Signature\nblock_rule Parse block-level syntax (parser, container) → 0/1/2\ninline_rule Parse inline syntax (parser, block) → Bool\nblock_modifier Transform blocks after parsing (parser, block) → nothing\ninline_modifier Transform inlines after parsing (parser, block) → nothing\n\nAll hooks return nothing by default (no rule registered).","category":"section"},{"location":"developing/#Block-Rule-Return-Values","page":"Developing Extensions","title":"Block Rule Return Values","text":"Value Meaning\n0 No match\n1 Matched container (keeps parsing children)\n2 Matched leaf block (stops block parsing)","category":"section"},{"location":"developing/#Inline-Rule-Return-Values","page":"Developing Extensions","title":"Inline Rule Return Values","text":"Value Meaning\nfalse No match, try next rule\ntrue Matched and consumed input","category":"section"},{"location":"developing/#Delimiter-Hooks","page":"Developing Extensions","title":"Delimiter Hooks","text":"For emphasis-like syntax (paired delimiters like ~~text~~), use these hooks instead of writing custom inline parsing:\n\n# Map (character, count) to node type\ndelim_nodes(::MyRule) = Dict(('~', 2) => Strikethrough)\n\n# Define flanking behavior: :standard, :underscore, or :permissive\nflanking_rule(::MyRule) = ('~', :standard)\n\n# Optional: characters that use odd-match logic\nuses_odd_match(::MyRule) = '~'\n\nWhen using delimiter hooks, your inline_rule should call handle_delim:\n\ninline_rule(::MyRule) = Rule(1, \"~\") do parser, block\n    handle_delim(parser, '~', block)\nend\ninline_modifier(::MyRule) = Rule(process_emphasis, 1)","category":"section"},{"location":"developing/#Writer-Functions","page":"Developing Extensions","title":"Writer Functions","text":"","category":"section"},{"location":"developing/#Signature","page":"Developing Extensions","title":"Signature","text":"Implement a writer for each output format:\n\nfunction write_html(::MyBlock, renderer, node, enter)\n    if enter\n        tag(renderer, \"div\", attributes(renderer, node, [\"class\" => \"my-block\"]))\n    else\n        tag(renderer, \"/div\")\n    end\nend\n\nThe enter parameter is true when entering the node, false when leaving. This allows generating opening/closing tags for containers.","category":"section"},{"location":"developing/#Required-Writers","page":"Developing Extensions","title":"Required Writers","text":"Function Output Format\nwrite_html HTML\nwrite_latex LaTeX\nwrite_typst Typst\nwrite_term Terminal (ANSI)\nwrite_markdown Markdown (roundtrip)\nwrite_json Pandoc AST JSON","category":"section"},{"location":"developing/#Writer-Utilities","page":"Developing Extensions","title":"Writer Utilities","text":"HTML:\n\ntag(w, name, attrs=[]) - emit HTML tag\nattributes(w, node, extra=[]) - format attributes from node.meta\n\nAll formats:\n\nliteral(w, str...) - emit raw text\ncr(w) - conditional newline (if not at line start)\nprint(w.buffer, str) - direct buffer access\n\nTerminal/Markdown:\n\npush_margin!(w, prefix) - add indentation prefix\npop_margin!(w) - remove indentation prefix\nprint_margin(w) - emit current margin\n\nTerminal:\n\nprint_literal(w, crayon, text, inv(crayon)) - styled output","category":"section"},{"location":"developing/#Parser-State","page":"Developing Extensions","title":"Parser State","text":"Key parser fields available during block parsing:\n\nparser.indent            # Current indentation level\nparser.indented          # Is line indented >= 4 spaces?\nparser.blank             # Is current line blank?\nparser.next_nonspace     # Position of next non-whitespace\nparser.line_number       # Current line number\n\n# Utility functions\nrest_from_nonspace(parser)      # Get remaining line from next non-space\nadvance_offset(parser, n, cols) # Advance position by n chars\nadvance_next_nonspace(parser)   # Move to next non-space\nadvance_to_end(parser)          # Consume rest of line\nclose_unmatched_blocks(parser)  # Finalize pending blocks\nadd_child(parser, type, offset) # Create new child node\n\nFor inline parsing:\n\ntrypeek(parser, Char)           # Peek current character\nconsume(parser, match)          # Consume regex match\nappend_child(block, node)       # Add inline child","category":"section"},{"location":"developing/#Registration","page":"Developing Extensions","title":"Registration","text":"Enable your rule with enable!:\n\nparser = Parser()\nenable!(parser, MyRule())\n\nRules can be disabled with disable!:\n\ndisable!(parser, SetextHeadingRule())  # Only allow ATX headings","category":"section"},{"location":"developing/#Example:-Highlight-(Inline)","page":"Developing Extensions","title":"Example: Highlight (Inline)","text":"A custom inline extension using delimiter hooks for ==highlighted text== syntax.\n\n# AST node\nstruct Highlight <: CommonMark.AbstractInline end\nCommonMark.is_container(::Highlight) = true\n\n# Rule type\nstruct HighlightRule end\n\n# Use delimiter infrastructure for ==text== parsing\nCommonMark.inline_rule(::HighlightRule) = CommonMark.Rule(1, \"=\") do parser, block\n    CommonMark.handle_delim(parser, '=', block)\nend\nCommonMark.inline_modifier(::HighlightRule) = CommonMark.Rule(CommonMark.process_emphasis, 1)\nCommonMark.delim_nodes(::HighlightRule) = Dict(('=', 2) => Highlight)\nCommonMark.flanking_rule(::HighlightRule) = ('=', :standard)\n\n# Writers\nCommonMark.write_html(::Highlight, r, n, ent) =\n    CommonMark.tag(r, ent ? \"mark\" : \"/mark\", ent ? CommonMark.attributes(r, n) : [])\n\nCommonMark.write_latex(::Highlight, w, n, ent) =\n    print(w.buffer, ent ? \"\\\\hl{\" : \"}\")\n\nCommonMark.write_term(::Highlight, w, n, ent) = nothing  # No terminal styling\n\nCommonMark.write_markdown(::Highlight, w, n, ent) = CommonMark.literal(w, \"==\")\nnothing # hide\n\nUsage:\n\nparser = Parser()\nenable!(parser, HighlightRule())\nast = parser(\"Some ==highlighted text== here.\")\nhtml(ast)","category":"section"},{"location":"developing/#Example:-Spoiler-Block","page":"Developing Extensions","title":"Example: Spoiler Block","text":"A custom block extension for spoiler/collapsible content using ??? title syntax.\n\n# AST node with title field\nstruct Spoiler <: CommonMark.AbstractBlock\n    title::String\nend\n\n# Container behavior\nCommonMark.is_container(::Spoiler) = true\nCommonMark.accepts_lines(::Spoiler) = false\nCommonMark.can_contain(::Spoiler, t) = !(t isa CommonMark.Item)\nCommonMark.finalize(::Spoiler, ::CommonMark.Parser, ::CommonMark.Node) = nothing\n\n# Continue if indented by 4 spaces or blank\nfunction CommonMark.continue_(::Spoiler, parser::CommonMark.Parser, ::CommonMark.Node)\n    if parser.indent >= 4\n        CommonMark.advance_offset(parser, 4, true)\n        return 0  # Continue\n    elseif parser.blank\n        CommonMark.advance_next_nonspace(parser)\n        return 0\n    else\n        return 1  # Close\n    end\nend\n\n# Rule type\nstruct SpoilerRule end\n\n# Block parsing function\nCommonMark.block_rule(::SpoilerRule) = CommonMark.Rule(0.5, \"?\") do parser, container\n    if !parser.indented\n        ln = CommonMark.rest_from_nonspace(parser)\n        m = match(r\"^\\?\\?\\? (.+)$\", ln)\n        if m !== nothing\n            CommonMark.close_unmatched_blocks(parser)\n            CommonMark.add_child(parser, Spoiler(m[1]), parser.next_nonspace)\n            CommonMark.advance_to_end(parser)\n            return 1  # Container block\n        end\n    end\n    return 0\nend\n\n# Writers\nfunction CommonMark.write_html(s::Spoiler, rend, node, enter)\n    if enter\n        CommonMark.tag(rend, \"details\", CommonMark.attributes(rend, node))\n        CommonMark.tag(rend, \"summary\")\n        print(rend.buffer, s.title)\n        CommonMark.tag(rend, \"/summary\")\n    else\n        CommonMark.tag(rend, \"/details\")\n    end\nend\n\nCommonMark.write_latex(s::Spoiler, w, n, ent) =\n    CommonMark.literal(w, ent ? \"\\\\begin{spoiler}{$(s.title)}\\n\" : \"\\\\end{spoiler}\\n\")\n\nCommonMark.write_term(::Spoiler, w, n, ent) = nothing\n\nfunction CommonMark.write_markdown(s::Spoiler, w, node, ent)\n    if ent\n        CommonMark.push_margin!(w, \"    \")\n        CommonMark.literal(w, \"??? \", s.title, \"\\n\")\n        CommonMark.print_margin(w)\n        CommonMark.literal(w, \"\\n\")\n    else\n        CommonMark.pop_margin!(w)\n        CommonMark.cr(w)\n    end\nend\nnothing # hide\n\nUsage:\n\nparser = Parser()\nenable!(parser, SpoilerRule())\nast = parser(\"\"\"\n??? Click to reveal\n    This content is hidden by default.\n    It can contain **formatted** text.\n\"\"\")\nhtml(ast)","category":"section"},{"location":"developing/#Extension-Patterns","page":"Developing Extensions","title":"Extension Patterns","text":"","category":"section"},{"location":"developing/#Block-Modifier","page":"Developing Extensions","title":"Block Modifier","text":"Transform existing nodes without custom parsing. Useful for detecting patterns in parsed content:\n\nblock_modifier(::MyRule) = Rule(50) do parser, block\n    if block.t isa Paragraph\n        # Check content and transform if needed\n        m = match(r\"^pattern\", block.literal)\n        if m !== nothing\n            block.t = MyCustomType()\n        end\n    end\nend\n\nSee GitHubAlertRule and TaskListRule for examples.","category":"section"},{"location":"developing/#Stateful-Rules","page":"Developing Extensions","title":"Stateful Rules","text":"Store state during parsing for cross-referencing:\n\nstruct FootnoteRule\n    cache::Dict{String,Node}\n    FootnoteRule() = new(Dict())\nend\n\nblock_rule(fr::FootnoteRule) = Rule(0.5, \"[\") do parser, container\n    # Store definitions in cache\n    fr.cache[id] = node\nend\n\ninline_rule(fr::FootnoteRule) = Rule(0.5, \"[\") do parser, block\n    # Reference cache to link footnotes\n    def = get(fr.cache, id, nothing)\nend","category":"section"},{"location":"ast/#Building-ASTs","page":"Building ASTs","title":"Building ASTs","text":"Build markdown documents programmatically using Node constructors instead of parsing text. This is useful for:\n\nGenerating documents from data: Create reports, documentation, or content from databases, APIs, or computation results\nTemplate systems: Build document structures that get filled with dynamic content\nDocument transformation: Modify parsed documents or create new ones based on existing ASTs\nTesting: Create specific AST structures for unit tests\n\nimport CommonMark as CM\nnothing # hide\n\ntip: Tip\nUse import CommonMark as CM to reduce verbosity in code that builds ASTs.","category":"section"},{"location":"ast/#How-It-Works","page":"Building ASTs","title":"How It Works","text":"The AST is a tree of Node objects. Each node has:\n\nA container type (e.g., Document, Paragraph, Strong) that defines what kind of element it is\nChildren for container nodes (blocks contain blocks or inlines; inlines contain inlines or text)\nA literal string for leaf nodes like Text, Code, and CodeBlock\nOptional metadata for attributes, IDs, and classes\n\nNodes are created with Node(Type, children...) where strings automatically become Text nodes:\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.Heading, 1, \"Hello World\"),\n    CM.Node(CM.Paragraph, \"Welcome to \", CM.Node(CM.Strong, \"CommonMark\"), \"!\")\n)\nCM.html(doc)\n\nThe constructed AST can be rendered to any output format: html(), latex(), markdown(), term(), typst(), or json().","category":"section"},{"location":"ast/#Block-Containers","page":"Building ASTs","title":"Block Containers","text":"Block elements form the document structure: paragraphs, headings, lists, etc. They occupy their own vertical space in the rendered output.","category":"section"},{"location":"ast/#Document","page":"Building ASTs","title":"Document","text":"The root container. Every AST must have a Document as its root node. It can contain any block elements except list items.\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.Paragraph, \"First paragraph.\"),\n    CM.Node(CM.Paragraph, \"Second paragraph.\")\n)\nCM.html(doc)","category":"section"},{"location":"ast/#Paragraph","page":"Building ASTs","title":"Paragraph","text":"The basic text container. Paragraphs hold inline content: text, emphasis, links, code spans, etc. Most text content lives inside paragraphs.\n\np = CM.Node(CM.Paragraph,\n    \"Plain text, \",\n    CM.Node(CM.Emph, \"italic\"),\n    \", and \",\n    CM.Node(CM.Strong, \"bold\"),\n    \".\"\n)\ndoc = CM.Node(CM.Document, p)\nCM.html(doc)","category":"section"},{"location":"ast/#Heading","page":"Building ASTs","title":"Heading","text":"Section headings with levels 1-6. The first argument is the level (1 = h1, 2 = h2, etc.), followed by the heading content.\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.Heading, 1, \"Main Title\"),\n    CM.Node(CM.Paragraph, \"Introduction paragraph.\"),\n    CM.Node(CM.Heading, 2, \"First Section\"),\n    CM.Node(CM.Paragraph, \"Section content.\"),\n    CM.Node(CM.Heading, 3, \"Subsection\")\n)\nCM.html(doc)\n\nHeadings can contain inline formatting:\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.Heading, 2, \"The \", CM.Node(CM.Code, \"Node\"), \" API\")\n)\nCM.html(doc)","category":"section"},{"location":"ast/#BlockQuote","page":"Building ASTs","title":"BlockQuote","text":"Quoted content, typically rendered with indentation or a vertical bar. Block quotes can contain any block elements including nested quotes.\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.BlockQuote,\n        CM.Node(CM.Paragraph, \"To be or not to be.\"),\n        CM.Node(CM.Paragraph, \"— Shakespeare\")\n    )\n)\nCM.html(doc)\n\nNested block quotes:\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.BlockQuote,\n        CM.Node(CM.Paragraph, \"Outer quote\"),\n        CM.Node(CM.BlockQuote,\n            CM.Node(CM.Paragraph, \"Inner quote\")\n        )\n    )\n)\nCM.html(doc)","category":"section"},{"location":"ast/#List-and-Item","page":"Building ASTs","title":"List and Item","text":"Lists contain Item nodes. By default, lists are unordered (bullet points). Use keyword arguments to customize:\n\nKeyword Type Default Description\nordered Bool false Numbered list instead of bullets\nstart Int 1 Starting number for ordered lists\ntight Bool true Tight spacing (no <p> tags around items)\n\nUnordered list:\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.List,\n        CM.Node(CM.Item, CM.Node(CM.Paragraph, \"First item\")),\n        CM.Node(CM.Item, CM.Node(CM.Paragraph, \"Second item\")),\n        CM.Node(CM.Item, CM.Node(CM.Paragraph, \"Third item\"))\n    )\n)\nCM.html(doc)\n\nOrdered list starting at 5:\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.List,\n        CM.Node(CM.Item, CM.Node(CM.Paragraph, \"Fifth\")),\n        CM.Node(CM.Item, CM.Node(CM.Paragraph, \"Sixth\"));\n        ordered=true, start=5\n    )\n)\nCM.html(doc)\n\nNested lists:\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.List,\n        CM.Node(CM.Item,\n            CM.Node(CM.Paragraph, \"Outer item\"),\n            CM.Node(CM.List,\n                CM.Node(CM.Item, CM.Node(CM.Paragraph, \"Nested item 1\")),\n                CM.Node(CM.Item, CM.Node(CM.Paragraph, \"Nested item 2\"))\n            )\n        )\n    )\n)\nCM.html(doc)","category":"section"},{"location":"ast/#CodeBlock","page":"Building ASTs","title":"CodeBlock","text":"Fenced code blocks for displaying source code. The info keyword specifies the language for syntax highlighting.\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.CodeBlock, \"function greet(name)\\n    println(\\\"Hello, \\$name!\\\")\\nend\"; info=\"julia\")\n)\nCM.html(doc)\n\nWithout a language:\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.CodeBlock, \"Plain text code block\\nNo syntax highlighting\")\n)\nCM.html(doc)","category":"section"},{"location":"ast/#ThematicBreak","page":"Building ASTs","title":"ThematicBreak","text":"A horizontal rule that separates sections. Takes no children or arguments.\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.Paragraph, \"Content above the break.\"),\n    CM.Node(CM.ThematicBreak),\n    CM.Node(CM.Paragraph, \"Content below the break.\")\n)\nCM.html(doc)","category":"section"},{"location":"ast/#HtmlBlock","page":"Building ASTs","title":"HtmlBlock","text":"Raw HTML that passes through unchanged. Use for content that can't be expressed in markdown, like complex layouts or embedded widgets.\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.HtmlBlock, \"<div class=\\\"warning\\\">\\n  <strong>Warning:</strong> Custom HTML content.\\n</div>\")\n)\nCM.html(doc)","category":"section"},{"location":"ast/#Inline-Containers","page":"Building ASTs","title":"Inline Containers","text":"Inline elements flow within text: emphasis, links, code spans, etc. They don't create line breaks by themselves.","category":"section"},{"location":"ast/#Emph-and-Strong","page":"Building ASTs","title":"Emph and Strong","text":"Emphasis (<em>, typically italic) and strong emphasis (<strong>, typically bold). Both are containers that can hold other inline content.\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.Paragraph,\n        \"This is \",\n        CM.Node(CM.Emph, \"emphasized\"),\n        \" and this is \",\n        CM.Node(CM.Strong, \"strongly emphasized\"),\n        \".\"\n    )\n)\nCM.html(doc)\n\nNested emphasis:\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.Paragraph,\n        CM.Node(CM.Strong, \"Bold with \", CM.Node(CM.Emph, \"italic\"), \" inside\")\n    )\n)\nCM.html(doc)","category":"section"},{"location":"ast/#Code","page":"Building ASTs","title":"Code","text":"Inline code spans for mentioning code within text. The argument is the literal code string.\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.Paragraph,\n        \"Call \",\n        CM.Node(CM.Code, \"process(data)\"),\n        \" to transform the input.\"\n    )\n)\nCM.html(doc)","category":"section"},{"location":"ast/#Link","page":"Building ASTs","title":"Link","text":"Hyperlinks with a destination URL and optional title. Links are containers—their children become the link text.\n\nKeyword Type Required Description\ndest String Yes URL or path\ntitle String No Tooltip text\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.Paragraph,\n        \"Visit the \",\n        CM.Node(CM.Link, \"official website\"; dest=\"https://example.com\", title=\"Example Site\"),\n        \" for more information.\"\n    )\n)\nCM.html(doc)\n\nLinks can contain formatting:\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.Paragraph,\n        CM.Node(CM.Link,\n            \"Click \",\n            CM.Node(CM.Strong, \"here\"),\n            \" to continue\";\n            dest=\"/next\"\n        )\n    )\n)\nCM.html(doc)","category":"section"},{"location":"ast/#Image","page":"Building ASTs","title":"Image","text":"Images with source URL and alt text. Unlike links, images don't contain children— the alt text is specified as a keyword argument.\n\nKeyword Type Required Description\ndest String Yes Image URL or path\nalt String No Alternative text\ntitle String No Tooltip text\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.Paragraph,\n        \"Here's a diagram: \",\n        CM.Node(CM.Image; dest=\"diagram.png\", alt=\"Architecture diagram\")\n    )\n)\nCM.html(doc)","category":"section"},{"location":"ast/#SoftBreak-and-LineBreak","page":"Building ASTs","title":"SoftBreak and LineBreak","text":"SoftBreak represents a line break in the source that becomes a space or newline depending on output format. LineBreak is a hard break (<br> in HTML).\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.Paragraph,\n        \"First line\",\n        CM.Node(CM.SoftBreak),\n        \"continues here (soft break becomes space).\"\n    ),\n    CM.Node(CM.Paragraph,\n        \"Line one\",\n        CM.Node(CM.LineBreak),\n        \"Line two (hard break)\"\n    )\n)\nCM.html(doc)","category":"section"},{"location":"ast/#HtmlInline","page":"Building ASTs","title":"HtmlInline","text":"Raw inline HTML for special formatting not available in markdown. Use paired tags for spans or single tags for elements like <br>.\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.Paragraph,\n        \"Text with \",\n        CM.Node(CM.HtmlInline, \"<mark>\"),\n        \"highlighted\",\n        CM.Node(CM.HtmlInline, \"</mark>\"),\n        \" content.\"\n    )\n)\nCM.html(doc)","category":"section"},{"location":"ast/#Extension-Types","page":"Building ASTs","title":"Extension Types","text":"Extension nodes represent syntax beyond standard CommonMark. They can be built programmatically regardless of whether the corresponding parser rule is enabled.","category":"section"},{"location":"ast/#Math","page":"Building ASTs","title":"Math","text":"Inline math (Math) and display math blocks (DisplayMath) for LaTeX-style equations. The argument is the LaTeX expression without delimiters.\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.Paragraph,\n        \"Einstein's famous equation: \",\n        CM.Node(CM.Math, \"E = mc^2\"),\n        \".\"\n    ),\n    CM.Node(CM.DisplayMath, \"\\\\int_0^\\\\infty e^{-x^2} dx = \\\\frac{\\\\sqrt{\\\\pi}}{2}\")\n)\nCM.html(doc)","category":"section"},{"location":"ast/#Strikethrough,-Subscript,-Superscript","page":"Building ASTs","title":"Strikethrough, Subscript, Superscript","text":"Text formatting for deleted text, subscripts, and superscripts. All are containers that hold inline content.\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.Paragraph,\n        CM.Node(CM.Strikethrough, \"removed text\"),\n        \", water is H\",\n        CM.Node(CM.Subscript, \"2\"),\n        \"O, and x\",\n        CM.Node(CM.Superscript, \"2\"),\n        \" means x squared.\"\n    )\n)\nCM.html(doc)","category":"section"},{"location":"ast/#Admonition","page":"Building ASTs","title":"Admonition","text":"Callout boxes for notes, warnings, tips, and other highlighted content. Takes a category, title, and block children.\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.Admonition, \"warning\", \"Important\",\n        CM.Node(CM.Paragraph, \"This operation cannot be undone.\")\n    ),\n    CM.Node(CM.Admonition, \"tip\", \"Pro Tip\",\n        CM.Node(CM.Paragraph, \"Use keyboard shortcuts for efficiency.\")\n    )\n)\nCM.html(doc)","category":"section"},{"location":"ast/#FencedDiv","page":"Building ASTs","title":"FencedDiv","text":"Generic container divs with CSS classes and IDs. Useful for custom styling or semantic grouping.\n\nKeyword Type Description\nclass String or Vector{String} CSS class(es)\nid String Element ID\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.FencedDiv,\n        CM.Node(CM.Paragraph, \"Important content here.\");\n        class=[\"highlight\", \"important\"], id=\"section-1\"\n    )\n)\nCM.html(doc)","category":"section"},{"location":"ast/#Footnotes","page":"Building ASTs","title":"Footnotes","text":"Footnote definitions and references. When building a Document, footnote links are automatically connected to their definitions.\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.Paragraph,\n        \"This claim needs a citation\",\n        CM.Node(CM.FootnoteLink, \"1\"),\n        \".\"\n    ),\n    CM.Node(CM.FootnoteDefinition, \"1\",\n        CM.Node(CM.Paragraph, \"Source: Journal of Examples, 2024.\")\n    )\n)\nCM.html(doc)","category":"section"},{"location":"ast/#GitHubAlert","page":"Building ASTs","title":"GitHubAlert","text":"GitHub-flavored alert blocks. Categories: note, tip, important, warning, caution. The title defaults to the capitalized category.\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.GitHubAlert, \"note\",\n        CM.Node(CM.Paragraph, \"This is informational.\")\n    ),\n    CM.Node(CM.GitHubAlert, \"warning\",\n        CM.Node(CM.Paragraph, \"Proceed with caution!\"); title=\"Danger Zone\"\n    )\n)\nCM.html(doc)","category":"section"},{"location":"ast/#TaskItem","page":"Building ASTs","title":"TaskItem","text":"Checkbox list items for task lists. Use checked=true for completed items. TaskItems go inside a List just like regular Item nodes.\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.Heading, 2, \"Todo\"),\n    CM.Node(CM.List,\n        CM.Node(CM.TaskItem, CM.Node(CM.Paragraph, \"Write documentation\")),\n        CM.Node(CM.TaskItem, CM.Node(CM.Paragraph, \"Add tests\"); checked=true),\n        CM.Node(CM.TaskItem, CM.Node(CM.Paragraph, \"Release\"))\n    )\n)\nCM.html(doc)","category":"section"},{"location":"ast/#Table","page":"Building ASTs","title":"Table","text":"Tables with headers and data rows. Build from TableHeader, TableBody, TableRow, and TableCell components.\n\nThe align keyword on Table sets column alignments: :left, :center, or :right.\n\nheader = CM.Node(CM.TableHeader,\n    CM.Node(CM.TableRow,\n        CM.Node(CM.TableCell, \"Name\"),\n        CM.Node(CM.TableCell, \"Value\"),\n        CM.Node(CM.TableCell, \"Status\")\n    )\n)\nrow1 = CM.Node(CM.TableRow,\n    CM.Node(CM.TableCell, \"Alpha\"),\n    CM.Node(CM.TableCell, \"100\"),\n    CM.Node(CM.TableCell, CM.Node(CM.Strong, \"Active\"))\n)\nrow2 = CM.Node(CM.TableRow,\n    CM.Node(CM.TableCell, \"Beta\"),\n    CM.Node(CM.TableCell, \"200\"),\n    CM.Node(CM.TableCell, \"Pending\")\n)\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.Table, header, row1, row2; align=[:left, :right, :center])\n)\nCM.html(doc)","category":"section"},{"location":"ast/#Citation","page":"Building ASTs","title":"Citation","text":"Academic citation references. Requires bibliography configuration for proper rendering.\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.Paragraph,\n        \"According to \",\n        CM.Node(CM.Citation, \"smith2020\"),\n        \", this approach is effective.\"\n    )\n)\nCM.html(doc)","category":"section"},{"location":"ast/#Raw-Content","page":"Building ASTs","title":"Raw Content","text":"Format-specific content that passes through only to matching output formats. Available types: LaTeXInline, LaTeXBlock, TypstInline, TypstBlock.\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.Paragraph,\n        \"This \",\n        CM.Node(CM.LaTeXInline, \"\\\\textbf{bold}\"),\n        \" only appears in LaTeX output.\"\n    )\n)\nCM.latex(doc)","category":"section"},{"location":"ast/#Reference-Links","page":"Building ASTs","title":"Reference Links","text":"Reference-style links preserve the original syntax for roundtripping. These nodes are produced when parsing with ReferenceLinkRule enabled.\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.Paragraph,\n        \"See the \",\n        CM.Node(CM.ReferenceLink, \"docs\"; dest=\"https://example.com\", label=\"docs\"),\n        \" or \",\n        CM.Node(CM.ReferenceLink, \"click here\"; dest=\"https://example.com\", label=\"docs\", style=:full),\n        \".\"\n    ),\n    CM.Node(CM.ReferenceDefinition; label=\"docs\", dest=\"https://example.com\")\n)\nCM.markdown(doc)\n\nType Children Keyword Args\nReferenceLink link text dest, label, title=\"\", style=:full\nReferenceImage alt text dest, label, title=\"\", style=:full\nReferenceDefinition — label, dest, title=\"\"\nUnresolvedReference link text label, style=:shortcut, image=false\n\nThe style can be :full, :collapsed, or :shortcut.","category":"section"},{"location":"ast/#Tree-Manipulation","page":"Building ASTs","title":"Tree Manipulation","text":"After constructing nodes, you can modify the tree structure using these functions:\n\nFunction Description\nappend_child(parent, child) Add child as last child of parent\nprepend_child(parent, child) Add child as first child of parent\ninsert_after(node, sibling) Insert sibling immediately after node\ninsert_before(node, sibling) Insert sibling immediately before node\nunlink(node) Remove node from its parent\nisnull(node) Check if node is the null node (empty reference)\ntext(string) Create a Text node with the given content","category":"section"},{"location":"ast/#Building-Incrementally","page":"Building ASTs","title":"Building Incrementally","text":"Instead of nesting everything in the constructor, you can build nodes step by step:\n\n# Create empty containers\ndoc = CM.Node(CM.Document)\npara = CM.Node(CM.Paragraph)\n\n# Add content\nCM.append_child(para, CM.text(\"Hello \"))\nCM.append_child(para, CM.Node(CM.Strong, \"world\"))\nCM.append_child(para, CM.text(\"!\"))\n\n# Attach to document\nCM.append_child(doc, para)\n\nCM.html(doc)","category":"section"},{"location":"ast/#Modifying-Existing-Trees","page":"Building ASTs","title":"Modifying Existing Trees","text":"You can also modify trees created by the parser:\n\n# Parse a document\nparser = CM.Parser()\ndoc = parser(\"# Original Title\\n\\nSome content.\")\n\n# Find and modify nodes\nfor (node, entering) in doc\n    if entering && node.t isa CM.Heading\n        # Prepend \"Chapter: \" to all headings\n        CM.prepend_child(node, CM.text(\"Chapter: \"))\n    end\nend\n\nCM.html(doc)","category":"section"},{"location":"ast/#Complete-Example","page":"Building ASTs","title":"Complete Example","text":"A realistic document combining multiple element types:\n\ndoc = CM.Node(CM.Document,\n    CM.Node(CM.Heading, 1, \"CommonMark.jl User Guide\"),\n\n    CM.Node(CM.Paragraph,\n        \"CommonMark.jl is a \",\n        CM.Node(CM.Strong, \"fast\"),\n        \" and \",\n        CM.Node(CM.Strong, \"spec-compliant\"),\n        \" markdown parser for Julia.\"\n    ),\n\n    CM.Node(CM.Admonition, \"tip\", \"Quick Start\",\n        CM.Node(CM.Paragraph,\n            \"Install with \",\n            CM.Node(CM.Code, \"Pkg.add(\\\"CommonMark\\\")\"),\n            \".\"\n        )\n    ),\n\n    CM.Node(CM.Heading, 2, \"Features\"),\n\n    CM.Node(CM.List,\n        CM.Node(CM.Item, CM.Node(CM.Paragraph,\n            CM.Node(CM.Link, \"Multiple output formats\"; dest=\"#outputs\"),\n            \": HTML, LaTeX, Typst, terminal\"\n        )),\n        CM.Node(CM.Item, CM.Node(CM.Paragraph,\n            \"Extensible parser with \",\n            CM.Node(CM.Code, \"enable!\"),\n            \" and \",\n            CM.Node(CM.Code, \"disable!\")\n        )),\n        CM.Node(CM.Item, CM.Node(CM.Paragraph, \"Full CommonMark specification support\"))\n    ),\n\n    CM.Node(CM.Heading, 2, \"Example\"),\n\n    CM.Node(CM.CodeBlock, \"\"\"\nusing CommonMark\n\nparser = Parser()\nenable!(parser, TableRule())\n\nast = parser(\"| A | B |\\\\n|---|---|\\\\n| 1 | 2 |\")\nhtml(ast)\"\"\"; info=\"julia\"),\n\n    CM.Node(CM.Paragraph,\n        \"See the \",\n        CM.Node(CM.Link, \"API Reference\"; dest=\"api.html\"),\n        \" for complete documentation.\"\n    )\n)\n\nCM.html(doc)","category":"section"},{"location":"ast/#Converting-from-Julia-Markdown","page":"Building ASTs","title":"Converting from Julia Markdown","text":"CommonMark.jl can convert Julia's stdlib Markdown.MD AST to CommonMark's Node AST. This enables migration of existing documentation or integration with tools that produce stdlib Markdown.\n\nusing Markdown  # Load first to trigger extension\nusing CommonMark\nimport CommonMark: Node\n\n# Parse with Julia's stdlib\nmd = Markdown.parse(\"# Hello World\\n\\nThis is **bold** and *italic* text.\")\n\n# Convert to CommonMark AST\nast = Node(md)\n\n# Render to any format\nCommonMark.html(ast)\n\nThe conversion handles all stdlib element types:\n\nStdlib Type CommonMark Type\nMD Document\nParagraph Paragraph\nHeader{N} Heading (level N)\nBold Strong\nItalic Emph\nCode (inline) Code\nCode (block) CodeBlock\nBlockQuote BlockQuote\nList List + Item\nHorizontalRule ThematicBreak\nLink Link\nImage Image\nLineBreak LineBreak\nTable Table hierarchy\nAdmonition Admonition\nFootnote FootnoteDefinition / FootnoteLink\nLaTeX Math\n\nMetadata from the stdlib MD object is preserved:\n\nmd = Markdown.MD([Markdown.Paragraph([\"Content\"])])\nmd.meta[:title] = \"My Document\"\nmd.meta[:author] = \"Author Name\"\n\nast = Node(md)\nast.meta[\"title\"], ast.meta[\"author\"]\n\nThe converted AST works with all CommonMark.jl output formats:\n\nmd = Markdown.parse(\"Visit [Julia](https://julialang.org).\")\nast = Node(md)\n\nprintln(\"HTML:     \", CommonMark.html(ast))\nprintln(\"LaTeX:    \", CommonMark.latex(ast))\nprintln(\"Markdown: \", CommonMark.markdown(ast))","category":"section"},{"location":"transforms/#transforms-page","page":"Transforms","title":"Transforms","text":"Transforms let you intercept and modify AST nodes during rendering. Use them for URL rewriting, syntax highlighting, document wrappers, and other output customizations.\n\nusing CommonMark\nparser = Parser()\nnothing # hide","category":"section"},{"location":"transforms/#Basic-Usage","page":"Transforms","title":"Basic Usage","text":"Pass a transform function to any writer:\n\nfunction my_transform(mime, container, node, entering, writer)\n    # Return (node, entering) - possibly modified\n    (node, entering)\nend\n\nast = parser(\"Hello *world*\")\nhtml(ast; transform = my_transform)\n\nThe transform is called for every node during tree traversal, both when entering and leaving container nodes.","category":"section"},{"location":"transforms/#Signature","page":"Transforms","title":"Signature","text":"transform(mime::MIME, container, node::Node, entering::Bool, writer::Writer) -> (Node, Bool)\n\nParameter Description\nmime Output format (e.g., MIME\"text/html\"())\ncontainer The node's container type (e.g., Link, CodeBlock)\nnode The AST node being rendered\nentering true when entering, false when leaving\nwriter The writer instance (access writer.env for config)\n\nImportant: You must define a catch-all fallback that passes nodes through unchanged:\n\nmy_transform(mime, ::CommonMark.AbstractContainer, node, entering, writer) = (node, entering)","category":"section"},{"location":"transforms/#Examples","page":"Transforms","title":"Examples","text":"","category":"section"},{"location":"transforms/#URL-Rewriting","page":"Transforms","title":"URL Rewriting","text":"Transform link destinations for your site structure:\n\nfunction xform(::MIME\"text/html\", link::CommonMark.Link, node, entering, writer)\n    if entering\n        name, _ = splitext(link.destination)\n        new_node = CommonMark.Node(CommonMark.Link;\n            dest = \"/docs/$name.html\",\n            title = link.title,\n        )\n        (new_node, entering)\n    else\n        (node, entering)\n    end\nend\nxform(mime, ::CommonMark.AbstractContainer, node, entering, writer) =\n    (node, entering)\n\nast = parser(\"[Guide](guide.md)\")\nhtml(ast; transform = xform)","category":"section"},{"location":"transforms/#Syntax-Highlighting","page":"Transforms","title":"Syntax Highlighting","text":"Replace code blocks with pre-rendered HTML:\n\nfunction xform(::MIME\"text/html\", ::CommonMark.CodeBlock, node, entering, writer)\n    lang = node.t.info === nothing ? \"\" : node.t.info\n    highlighted = \"\"\"\n        <pre class=\"highlight\"><code class=\"language-$lang\">$(node.literal)</code></pre>\n        \"\"\"\n    (CommonMark.Node(CommonMark.HtmlBlock, highlighted), entering)\nend\nxform(mime, ::CommonMark.AbstractContainer, node, entering, writer) =\n    (node, entering)\n\nast = parser(\"```julia\\nx = 1\\n```\")\nhtml(ast; transform = xform)","category":"section"},{"location":"transforms/#Document-Wrapper","page":"Transforms","title":"Document Wrapper","text":"Add HTML structure around the rendered content:\n\nfunction xform(::MIME\"text/html\", ::CommonMark.Document, node, entering, writer)\n    if entering\n        title = get(writer.env, \"title\", \"Untitled\")\n        CommonMark.literal(writer, \"\"\"<!DOCTYPE html>\n<html>\n<head><title>$title</title></head>\n<body>\n\"\"\")\n    else\n        CommonMark.literal(writer, \"\"\"</body>\n</html>\n\"\"\")\n    end\n    (node, entering)\nend\nxform(mime, ::CommonMark.AbstractContainer, node, entering, writer) =\n    (node, entering)\n\nast = parser(\"# Hello\\n\\nWorld\")\nenv = Dict{String,Any}(\"title\" => \"My Page\")\nhtml(ast, env; transform = xform)","category":"section"},{"location":"transforms/#Format-Specific-Transforms","page":"Transforms","title":"Format-Specific Transforms","text":"Dispatch on MIME type for format-specific behavior:\n\nfunction xform(::MIME\"text/html\", link::CommonMark.Link, node, entering, writer)\n    if entering\n        dest = link.destination * \"?format=html\"\n        (CommonMark.Node(CommonMark.Link; dest = dest, title = link.title), entering)\n    else\n        (node, entering)\n    end\nend\n\nfunction xform(::MIME\"text/latex\", link::CommonMark.Link, node, entering, writer)\n    if entering\n        dest = link.destination * \"?format=latex\"\n        (CommonMark.Node(CommonMark.Link; dest = dest, title = link.title), entering)\n    else\n        (node, entering)\n    end\nend\n\nxform(mime, ::CommonMark.AbstractContainer, node, entering, writer) =\n    (node, entering)\n\nast = parser(\"[link](page)\")\nprintln(html(ast; transform = xform))\nprintln(latex(ast; transform = xform))","category":"section"},{"location":"transforms/#Accessing-Configuration","page":"Transforms","title":"Accessing Configuration","text":"Use writer.env to read configuration passed to the writer:\n\nfunction xform(::MIME\"text/html\", link::CommonMark.Link, node, entering, writer)\n    if entering\n        base = get(writer.env, \"base_url\", \"\")\n        dest = base * link.destination\n        (CommonMark.Node(CommonMark.Link; dest = dest, title = link.title), entering)\n    else\n        (node, entering)\n    end\nend\nxform(mime, ::CommonMark.AbstractContainer, node, entering, writer) =\n    (node, entering)\n\nast = parser(\"[link](page)\")\nenv = Dict{String,Any}(\"base_url\" => \"https://example.com/\")\nhtml(ast, env; transform = xform)","category":"section"},{"location":"transforms/#Migration-from-Previous-API","page":"Transforms","title":"Migration from Previous API","text":"note: For existing users\nSkip this section if you're new to CommonMark.jl.\n\nIf you were using the previous env-based hooks, here's how to migrate:\n\nPrevious New\nenv[\"smartlink-engine\"] Transform on Link / Image\nenv[\"syntax-highlighter\"] Transform on CodeBlock\nenv[\"template-engine\"] Transform on Document\n\nThe new system uses Julia's multiple dispatch, so you define methods for specific container types rather than passing function values in a dictionary.","category":"section"},{"location":"#CommonMark.jl","page":"Home","title":"CommonMark.jl","text":"A CommonMark-compliant parser for Julia.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Spec compliant: Passes the CommonMark spec test suite\nMultiple outputs: HTML, LaTeX, Typst, terminal (ANSI), Jupyter notebooks\nMarkdown roundtrip: Parse and re-emit normalized markdown\nModular parser: Enable/disable individual syntax rules\nExtensions: Tables, footnotes, math, front matter, admonitions, and more","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"CommonMark\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"Create a parser, parse some markdown, and render it to HTML:\n\nusing CommonMark\n\nparser = Parser()\nast = parser(\"Hello *world*\")\nhtml(ast)\n\nThe parser returns an abstract syntax tree (AST) that can be rendered to multiple output formats or inspected programmatically.","category":"section"},{"location":"#Parsing","page":"Home","title":"Parsing","text":"The parser is callable on strings:\n\nast = parser(\"# Heading\\n\\nParagraph\")\nhtml(ast)\n\nFor files, use open with the parser:\n\nast = open(parser, \"document.md\")","category":"section"},{"location":"#Output-Formats","page":"Home","title":"Output Formats","text":"The same AST can be rendered to different formats. Each format has its own writer function that returns a string or writes to a file/IO.\n\nast = parser(\"# Title\\n\\n**Bold** and *italic*.\")\nnothing # hide\n\nHTML for web pages:\n\nhtml(ast)\n\nLaTeX for documents and papers:\n\nlatex(ast)\n\nMarkdown for normalization and roundtripping:\n\nmarkdown(ast)\n\nOther formats include typst() for Typst documents, term() for terminal output with ANSI colors, notebook() for Jupyter notebooks, and json() for Pandoc AST JSON (enables export to docx, epub, rst, etc.).\n\nAll writer functions accept a filename or IO as the first argument:\n\nhtml(\"output.html\", ast)\nterm(stdout, ast)","category":"section"},{"location":"#Transforms","page":"Home","title":"Transforms","text":"Writers accept a transform keyword argument to intercept and modify nodes during rendering. Use transforms for URL rewriting, syntax highlighting, or wrapping output in templates:\n\n# Rewrite .md links to .html for static sites\nfunction rewrite_links(::MIME\"text/html\", link::CommonMark.Link, node, entering, writer)\n    entering || return (node, entering)\n    dest = replace(link.destination, \".md\" => \".html\")\n    (CommonMark.Node(CommonMark.Link; dest, title=link.title), entering)\nend\nrewrite_links(mime, ::CommonMark.AbstractContainer, node, entering, writer) = (node, entering)\n\nast = parser(\"[Guide](guide.md)\")\nhtml(ast; transform = rewrite_links)\n\nSee the Transforms page for full documentation.","category":"section"},{"location":"#Customization","page":"Home","title":"Customization","text":"The parser is modular. Each piece of syntax (headings, lists, emphasis, etc.) is handled by a rule that can be enabled or disabled independently.\n\nBy default, all standard CommonMark syntax is enabled. Extensions add syntax beyond the spec:\n\nusing CommonMark\n\nparser = Parser()\nenable!(parser, TableRule())\nenable!(parser, FootnoteRule())\nenable!(parser, MathRule())\n\nast = parser(\"\"\"\n| A | B |\n|---|---|\n| 1 | 2 |\n\"\"\")\nhtml(ast)\n\nDefault rules can be disabled if you want stricter or simpler parsing:\n\nparser = Parser()\ndisable!(parser, SetextHeadingRule())  # Only allow # headings, not underlined\nnothing # hide\n\nSee Core Rules for the default syntax and Extensions for additional features like tables, math, and admonitions.","category":"section"},{"location":"extensions/#extensions-page","page":"Extensions","title":"Extensions","text":"Extensions add syntax beyond the CommonMark specification. They must be explicitly enabled with enable!.\n\nusing CommonMark\nnothing # hide","category":"section"},{"location":"extensions/#Tables","page":"Extensions","title":"Tables","text":"Pipe-style tables from GitHub Flavored Markdown. Tables require a header row and a separator row that defines column alignment.\n\nparser = Parser()\nenable!(parser, TableRule())\n\nast = parser(\"\"\"\n| Column One | Column Two | Column Three |\n|:---------- | ---------- |:------------:|\n| Row `1`    | Column `2` |              |\n| *Row* 2    | **Row** 2  | Column 3     |\n\"\"\")\nhtml(ast)\n\nAlignment is set with colons in the separator: :--- left, ---: right, :---: center. Cells can contain inline formatting. Escape literal pipes with backslashes.","category":"section"},{"location":"extensions/#Admonitions","page":"Extensions","title":"Admonitions","text":"Callout boxes for notes, warnings, tips, and other highlighted content. Common in technical documentation.\n\nparser = Parser()\nenable!(parser, AdmonitionRule())\n\nast = parser(\"\"\"\n!!! note \"Custom Title\"\n    This is an admonition block.\n\n!!! warning\n    Title defaults to category name.\n\"\"\")\nhtml(ast)\n\nThe category (note, warning, tip, etc.) determines styling. An optional quoted string overrides the title. Content must be indented by 4 spaces.","category":"section"},{"location":"extensions/#Footnotes","page":"Extensions","title":"Footnotes","text":"Reference-style footnotes that collect at the end of the document. Useful for citations, asides, and additional context without interrupting flow.\n\nparser = Parser()\nenable!(parser, FootnoteRule())\n\nast = parser(\"\"\"\nHere is a footnote reference[^1].\n\n[^1]: This is the footnote content.\n\"\"\")\nhtml(ast)\n\nFootnote identifiers can be any word or number. Definitions can appear anywhere in the document and will be collected at the end.","category":"section"},{"location":"extensions/#Typography","page":"Extensions","title":"Typography","text":"Converts ASCII punctuation to proper typographic characters. Makes documents look more polished without requiring special input.\n\nparser = Parser()\nenable!(parser, TypographyRule())\n\nast = parser(\"\\\"Hello\\\" -- Pro tip... use 'single quotes' too --- or not.\")\nhtml(ast)\n\nConversions: straight quotes to curly quotes, ... to ellipsis, -- to en-dash, --- to em-dash. Disable specific conversions with keyword arguments:\n\nenable!(parser, TypographyRule(double_quotes=false, dashes=false))","category":"section"},{"location":"extensions/#Math","page":"Extensions","title":"Math","text":"LaTeX math expressions for technical and scientific documents.","category":"section"},{"location":"extensions/#Julia-style-(double-backticks)","page":"Extensions","title":"Julia-style (double backticks)","text":"Uses double backticks for inline math, matching Julia's docstring convention. Display math uses fenced code blocks with math as the language.\n\nparser = Parser()\nenable!(parser, MathRule())\n\nast = parser(\"Inline ``E = mc^2`` math.\")\nhtml(ast)\n\nDisplay math with fenced blocks:\n\nast = parser(\"\"\"\n```math\n\\\\int_0^\\\\infty e^{-x^2} dx\n```\n\"\"\")\nhtml(ast)","category":"section"},{"location":"extensions/#Dollar-style","page":"Extensions","title":"Dollar-style","text":"Traditional LaTeX syntax with single $ for inline and double $$ for display. More familiar to users coming from LaTeX or other markdown flavors.\n\nparser = Parser()\nenable!(parser, DollarMathRule())\n\nast = parser(\"Inline \\$E = mc^2\\$ math.\")\nhtml(ast)","category":"section"},{"location":"extensions/#Attributes","page":"Extensions","title":"Attributes","text":"Attach IDs, classes, and arbitrary key-value pairs to elements. Useful for styling, linking, and integrating with JavaScript.\n\nparser = Parser()\nenable!(parser, AttributeRule())\n\nast = parser(\"\"\"\n{#my-id .highlight}\n# Heading\n\"\"\")\nhtml(ast)\n\nBlock attributes go above the target element. Inline attributes go after:\n\nast = parser(\"*text*{.important}\")\nhtml(ast)\n\nCSS shorthand: #foo expands to id=\"foo\", .bar expands to class=\"bar\".","category":"section"},{"location":"extensions/#Strikethrough","page":"Extensions","title":"Strikethrough","text":"Marks deleted or outdated text. Renders as <del> in HTML.\n\nparser = Parser()\nenable!(parser, StrikethroughRule())\n\nast = parser(\"~~deleted text~~\")\nhtml(ast)","category":"section"},{"location":"extensions/#Subscript","page":"Extensions","title":"Subscript","text":"Chemical formulas, mathematical notation, and other subscripted text.\n\nparser = Parser()\nenable!(parser, SubscriptRule())\n\nast = parser(\"H~2~O\")\nhtml(ast)\n\nCan be combined with StrikethroughRule since they use different tilde counts (single vs double).","category":"section"},{"location":"extensions/#Superscript","page":"Extensions","title":"Superscript","text":"Exponents, ordinals, and other superscripted text.\n\nparser = Parser()\nenable!(parser, SuperscriptRule())\n\nast = parser(\"x^2^\")\nhtml(ast)","category":"section"},{"location":"extensions/#Task-Lists","page":"Extensions","title":"Task Lists","text":"Interactive checklists from GitHub Flavored Markdown. Useful for todo lists and progress tracking.\n\nparser = Parser()\nenable!(parser, TaskListRule())\n\nast = parser(\"\"\"\n- [ ] Unchecked\n- [x] Checked\n\"\"\")\nhtml(ast)","category":"section"},{"location":"extensions/#GitHub-Alerts","page":"Extensions","title":"GitHub Alerts","text":"Styled callouts matching GitHub's markdown alerts. Similar to admonitions but with GitHub's specific syntax and categories.\n\nparser = Parser()\nenable!(parser, GitHubAlertRule())\n\nast = parser(\"\"\"\n> [!NOTE]\n> Useful information.\n\n> [!WARNING]\n> Important warning.\n\"\"\")\nhtml(ast)\n\nSupported types: NOTE, TIP, IMPORTANT, WARNING, CAUTION.","category":"section"},{"location":"extensions/#Fenced-Divs","page":"Extensions","title":"Fenced Divs","text":"Generic containers from Pandoc. Wrap arbitrary content in a div with classes and attributes. Useful for custom styling and semantic markup.\n\nparser = Parser()\nenable!(parser, FencedDivRule())\n\nast = parser(\"\"\"\n::: warning\nThis is a warning.\n:::\n\"\"\")\nhtml(ast)\n\nDivs can be nested by using more colons for outer fences.","category":"section"},{"location":"extensions/#Front-Matter","page":"Extensions","title":"Front Matter","text":"Structured metadata at the start of a document. Commonly used for titles, authors, dates, and configuration in static site generators.\n\nusing YAML\n\nparser = Parser()\nenable!(parser, FrontMatterRule(yaml=YAML.load))\n\nast = parser(\"\"\"\n---\ntitle: My Document\nauthor: Jane Doe\n---\n\nContent here.\n\"\"\")\nfrontmatter(ast)\n\nDelimiters determine format: --- for YAML, +++ for TOML, ;;; for JSON. Pass the appropriate parser function for each format you want to support.","category":"section"},{"location":"extensions/#Citations","page":"Extensions","title":"Citations","text":"Academic-style citations with Pandoc syntax. Requires bibliography data in CSL-JSON format passed to the writer.\n\nparser = Parser()\nenable!(parser, CitationRule())\n\nast = parser(\"According to @doe2020, this is true.\")\n\n# Bibliography as CSL-JSON array\nbib = [Dict(\n    \"id\" => \"doe2020\",\n    \"author\" => [Dict(\"family\" => \"Doe\", \"given\" => \"Jane\")],\n    \"title\" => \"Example Article\",\n    \"issued\" => Dict(\"date-parts\" => [[2020]])\n)]\nhtml(ast, Dict{String,Any}(\"references\" => bib))\n\nBracketed syntax groups multiple citations: [@doe2020; @smith2021]. Brackets render as parentheses in the output.","category":"section"},{"location":"extensions/#Auto-Identifiers","page":"Extensions","title":"Auto Identifiers","text":"Automatically generates IDs for headings based on their text. Enables linking directly to sections.\n\nparser = Parser()\nenable!(parser, AutoIdentifierRule())\n\nast = parser(\"# My Heading\")\nhtml(ast)\n\nIDs are slugified: lowercased, spaces become hyphens, special characters removed. Duplicate headings get numeric suffixes.","category":"section"},{"location":"extensions/#Reference-Links","page":"Extensions","title":"Reference Links","text":"Preserves reference-style link syntax in the AST instead of resolving it during parsing. Enables accurate markdown roundtripping and detection of undefined references.\n\nparser = Parser()\nenable!(parser, ReferenceLinkRule())\n\nast = parser(\"\"\"\n[full style][ref]\n[collapsed style][]\n[shortcut style]\n\n[ref]: https://example.com\n[collapsed style]: /url\n[shortcut style]: /url\n\"\"\")\nmarkdown(ast)\n\nThe three reference styles are preserved:\n\nFull: [text][label] - explicit label\nCollapsed: [text][] - label matches text\nShortcut: [text] - implicit label","category":"section"},{"location":"extensions/#Detecting-Undefined-References","page":"Extensions","title":"Detecting Undefined References","text":"When enabled, undefined references become UnresolvedReference nodes instead of literal text. This enables tools to find broken links:\n\nast = parser(\"[undefined link][missing]\")\nfor (node, entering) in ast\n    if entering && node.t isa CommonMark.UnresolvedReference\n        ref = node.t\n        println(\"Undefined: label='$(ref.label)', style=$(ref.style), image=$(ref.image)\")\n    end\nend","category":"section"},{"location":"extensions/#Raw-Content","page":"Extensions","title":"Raw Content","text":"Pass format-specific content through unchanged. Useful for embedding LaTeX commands, HTML widgets, or other content that shouldn't be processed.\n\nparser = Parser()\nenable!(parser, RawContentRule())\n\nast = parser(\"Inline: `\\\\textbf{bold}`{=latex}\\n\\n```{=latex}\\n\\\\begin{center}\\nCentered\\n\\\\end{center}\\n```\")\nnothing # hide\n\nRaw content only appears in its target format:\n\nlatex(ast)\n\nhtml(ast)  # LaTeX content omitted\n\nThe format name (html, latex, typst) is specified in the attribute. The parser automatically determines inline vs block from context. Custom formats can be added by passing type mappings to RawContentRule.","category":"section"}]
}
