var documenterSearchIndex = {"docs":
[{"location":"api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"api/#CommonMark.AdmonitionRule","page":"API Reference","title":"CommonMark.AdmonitionRule","text":"AdmonitionRule()\n\nParse admonition blocks (notes, warnings, tips, etc.).\n\nNot enabled by default. Uses !!! syntax with a category and optional title.\n\n!!! note \"Custom Title\"\n    This is an admonition block.\n    It can contain multiple paragraphs.\n\n!!! warning\n    Default title is the category name.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.AsteriskEmphasisRule","page":"API Reference","title":"CommonMark.AsteriskEmphasisRule","text":"AsteriskEmphasisRule()\n\nParse emphasis using asterisks (* and **).\n\nEnabled by default. Single for italic, double for bold.\n\n*italic* and **bold** and ***both***\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.AttributeRule","page":"API Reference","title":"CommonMark.AttributeRule","text":"AttributeRule()\n\nParse attribute syntax to attach metadata to elements.\n\nNot enabled by default. Uses {#id .class key=value} syntax after elements.\n\n# Heading {#custom-id .highlight}\n\nParagraph with attributes.\n{.note}\n\n[Link](url){target=_blank}\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.AtxHeadingRule","page":"API Reference","title":"CommonMark.AtxHeadingRule","text":"AtxHeadingRule()\n\nParse ATX-style headings (# Heading).\n\nEnabled by default. Supports levels 1-6 with corresponding number of # characters.\n\n# Heading 1\n## Heading 2\n### Heading 3\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.AutoIdentifierRule","page":"API Reference","title":"CommonMark.AutoIdentifierRule","text":"AutoIdentifierRule()\n\nAutomatically generate IDs for headings.\n\nNot enabled by default. IDs are slugified from heading text. Duplicate IDs get numeric suffixes. Headings with explicit IDs (via AttributeRule) are preserved.\n\n# My Heading        → <h1 id=\"my-heading\">\n# My Heading        → <h1 id=\"my-heading-1\"> (duplicate)\n# Custom {#my-id}   → <h1 id=\"my-id\"> (with AttributeRule)\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.AutolinkRule","page":"API Reference","title":"CommonMark.AutolinkRule","text":"AutolinkRule()\n\nParse autolinks (<url> and <email@example.com>).\n\nEnabled by default. URLs must include a scheme.\n\n<https://example.com>\n<user@example.com>\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.BlockQuoteRule","page":"API Reference","title":"CommonMark.BlockQuoteRule","text":"BlockQuoteRule()\n\nParse block quotes (> quoted text).\n\nEnabled by default. Block quotes can be nested and contain other block elements.\n\n> This is a block quote.\n>\n> > Nested quote.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.CitationRule","page":"API Reference","title":"CommonMark.CitationRule","text":"CitationRule()\n\nParse citation references using @key or [@key] syntax.\n\nNot enabled by default. Citations can be bare (@smith2020) or bracketed ([@smith2020]). Requires a bibliography to be configured for rendering.\n\nAccording to @smith2020, this is true.\n\nMultiple citations: [@smith2020; @jones2021]\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.DollarMathRule","page":"API Reference","title":"CommonMark.DollarMathRule","text":"DollarMathRule()\n\nParse LaTeX math with dollar sign delimiters (without backticks).\n\nNot enabled by default. Inline math uses $...$, display math uses $$...$$.\n\nInline: $E = mc^2$\n\nDisplay:\n$$\n\\int_0^\\infty e^{-x^2} dx\n$$\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.FencedCodeBlockRule","page":"API Reference","title":"CommonMark.FencedCodeBlockRule","text":"FencedCodeBlockRule()\n\nParse fenced code blocks (triple backticks or tildes).\n\nEnabled by default. Supports optional language identifier.\n\n```julia\nprintln(\"Hello\")\n```\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.FencedDivRule","page":"API Reference","title":"CommonMark.FencedDivRule","text":"FencedDivRule()\n\nParse Pandoc-style fenced divs (::: class blocks).\n\nNot enabled by default. Creates generic container elements with CSS classes. Divs can be nested by using more colons.\n\n::: warning\nThis is a warning div.\n:::\n\n:::: outer\n::: inner\nNested divs.\n:::\n::::\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.FootnoteRule","page":"API Reference","title":"CommonMark.FootnoteRule","text":"FootnoteRule()\n\nParse footnote definitions and references.\n\nNot enabled by default. Define footnotes with [^id]: and reference with [^id].\n\nHere is a footnote reference[^1].\n\n[^1]: This is the footnote content.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.FrontMatterRule","page":"API Reference","title":"CommonMark.FrontMatterRule","text":"FrontMatterRule(; yaml=identity, toml=identity, json=identity)\n\nParse YAML, TOML, or JSON front matter at document start.\n\nNot enabled by default. Front matter is delimited by --- (YAML), +++ (TOML), or ;;; (JSON). Pass parser functions for each format.\n\n---\ntitle: My Document\nauthor: Jane Doe\n---\n\nDocument content here.\n\nUse frontmatter to extract the parsed data.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.GitHubAlertRule","page":"API Reference","title":"CommonMark.GitHubAlertRule","text":"GitHubAlertRule()\n\nParse GitHub-style alert blockquotes.\n\nNot enabled by default. Converts blockquotes starting with [!TYPE] into styled alert boxes. Supported types: NOTE, TIP, IMPORTANT, WARNING, CAUTION.\n\n> [!NOTE]\n> This is a note alert.\n\n> [!WARNING]\n> This is a warning alert.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.HtmlBlockRule","page":"API Reference","title":"CommonMark.HtmlBlockRule","text":"HtmlBlockRule()\n\nParse raw HTML blocks.\n\nEnabled by default. Recognizes common HTML tags and passes them through unchanged.\n\n<div class=\"warning\">\n  <p>Raw HTML content</p>\n</div>\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.HtmlEntityRule","page":"API Reference","title":"CommonMark.HtmlEntityRule","text":"HtmlEntityRule()\n\nParse HTML entities (&amp;, &#123;, &#x7B;).\n\nEnabled by default. Converts entities to their Unicode equivalents.\n\n&copy; &amp; &#60; &#x3C;\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.HtmlInlineRule","page":"API Reference","title":"CommonMark.HtmlInlineRule","text":"HtmlInlineRule()\n\nParse inline HTML tags.\n\nEnabled by default. Passes through raw HTML tags unchanged.\n\nThis has <em>inline HTML</em> tags.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.ImageRule","page":"API Reference","title":"CommonMark.ImageRule","text":"ImageRule()\n\nParse inline and reference images.\n\nEnabled by default. Same syntax as links but prefixed with !.\n\n![alt text](image.png)\n![alt text][ref]\n\n[ref]: image.png\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.IndentedCodeBlockRule","page":"API Reference","title":"CommonMark.IndentedCodeBlockRule","text":"IndentedCodeBlockRule()\n\nParse indented code blocks (4 spaces or 1 tab).\n\nEnabled by default.\n\n    code here\n    more code\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.InlineCodeRule","page":"API Reference","title":"CommonMark.InlineCodeRule","text":"InlineCodeRule()\n\nParse inline code spans (backtick-delimited).\n\nEnabled by default. Uses matching backtick counts for nesting.\n\nUse `code` inline or `` `backticks` `` inside.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.LinkRule","page":"API Reference","title":"CommonMark.LinkRule","text":"LinkRule()\n\nParse inline and reference links.\n\nEnabled by default. Supports both inline [text](url) and reference [text][ref] styles.\n\n[inline link](https://example.com)\n[reference link][ref]\n\n[ref]: https://example.com\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.ListItemRule","page":"API Reference","title":"CommonMark.ListItemRule","text":"ListItemRule()\n\nParse list items (bulleted and ordered lists).\n\nEnabled by default. Supports -, +, * for bullets and 1., 1) for ordered.\n\n- Item one\n- Item two\n\n1. First\n2. Second\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.MathRule","page":"API Reference","title":"CommonMark.MathRule","text":"MathRule()\n\nParse LaTeX math in double-backtick code spans and fenced code blocks.\n\nNot enabled by default. Inline math uses double backticks (``...``), display math uses math ``` fenced blocks.\n\nInline: ``E = mc^2``\n\nDisplay:\n```math\n\\int_0^\\infty e^{-x^2} dx\n```\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.Parser","page":"API Reference","title":"CommonMark.Parser","text":"Parser()\n\nCreate a CommonMark parser with default block and inline rules enabled.\n\nThe parser can be called directly on a string to produce an AST, which can then be rendered to various output formats using html, latex, term, markdown, notebook, or typst.\n\nExamples\n\np = Parser()\nast = p(\"# Hello\\n\\nWorld\")\nhtml(ast)  # \"<h1>Hello</h1>\\n<p>World</p>\\n\"\n\nUse enable! and disable! to customize which rules are active.\n\np = Parser()\nenable!(p, TableRule())\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.RawContentRule","page":"API Reference","title":"CommonMark.RawContentRule","text":"RawContentRule(; formats...)\n\nParse format-specific raw content blocks.\n\nNot enabled by default. Uses content=format syntax for inline and fenced blocks with {=format} for blocks. The _inline or _block suffix is added automatically based on context.\n\n`<span>html</span>`{=html}\n\n\n{=latex} \\textbf{LaTeX content}\n\n\n\nDefault formats: html, latex, typst.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.ReferenceLinkRule","page":"API Reference","title":"CommonMark.ReferenceLinkRule","text":"ReferenceLinkRule()\n\nPreserve reference link style in the AST.\n\nNot enabled by default. By default, reference links are resolved to inline links during parsing. This rule preserves the original reference style (full, collapsed, or shortcut) for roundtrip rendering.\n\n[full style][ref]\n[collapsed style][]\n[shortcut style]\n\n[ref]: https://example.com\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.SetextHeadingRule","page":"API Reference","title":"CommonMark.SetextHeadingRule","text":"SetextHeadingRule()\n\nParse setext-style headings (underlined with = or -).\n\nEnabled by default. Only supports levels 1 and 2.\n\nHeading 1\n=========\n\nHeading 2\n---------\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.StrikethroughRule","page":"API Reference","title":"CommonMark.StrikethroughRule","text":"StrikethroughRule()\n\nParse strikethrough text (~~deleted~~).\n\nNot enabled by default. Uses double tildes to mark deleted text.\n\n~~This text is struck through.~~\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.SubscriptRule","page":"API Reference","title":"CommonMark.SubscriptRule","text":"SubscriptRule()\n\nParse subscript text (~subscript~).\n\nNot enabled by default. Uses single tildes to mark subscript text.\n\nH~2~O renders as H₂O\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.SuperscriptRule","page":"API Reference","title":"CommonMark.SuperscriptRule","text":"SuperscriptRule()\n\nParse superscript text (^superscript^).\n\nNot enabled by default. Uses carets to mark superscript text.\n\nx^2^ renders as x²\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.TableRule","page":"API Reference","title":"CommonMark.TableRule","text":"TableRule()\n\nParse GitHub Flavored Markdown pipe tables.\n\nNot enabled by default. Tables use | to separate columns and require a header separator row.\n\n| Header 1 | Header 2 |\n|----------|----------|\n| Cell 1   | Cell 2   |\n\nAlignment can be specified with : in the separator row:\n\n:--- left align\n:---: center align\n---: right align\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.TaskListRule","page":"API Reference","title":"CommonMark.TaskListRule","text":"TaskListRule()\n\nParse GitHub-style task list items.\n\nNot enabled by default. Converts list items starting with [ ] or [x] into interactive checkboxes in HTML output.\n\n- [ ] Unchecked item\n- [x] Checked item\n- Regular item\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.ThematicBreakRule","page":"API Reference","title":"CommonMark.ThematicBreakRule","text":"ThematicBreakRule()\n\nParse thematic breaks (horizontal rules).\n\nEnabled by default. Requires 3+ of *, -, or _ characters.\n\n***\n\n---\n\n___\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.TypographyRule","page":"API Reference","title":"CommonMark.TypographyRule","text":"TypographyRule(; double_quotes=true, single_quotes=true, ellipses=true, dashes=true)\n\nConvert ASCII punctuation to typographic equivalents.\n\nNot enabled by default. Converts:\n\n\"...\" to \"...\" (curly double quotes)\n'...' to '...' (curly single quotes)\n... to … (ellipsis)\n-- to – and --- to — (en/em dashes)\n\nDisable specific conversions with keyword arguments.\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.UnderscoreEmphasisRule","page":"API Reference","title":"CommonMark.UnderscoreEmphasisRule","text":"UnderscoreEmphasisRule()\n\nParse emphasis using underscores (_ and __).\n\nEnabled by default. Single for italic, double for bold.\n\n_italic_ and __bold__ and ___both___\n\n\n\n\n\n","category":"type"},{"location":"api/#CommonMark.ast_equal-Tuple{CommonMark.Node, CommonMark.Node}","page":"API Reference","title":"CommonMark.ast_equal","text":"ast_equal(a::Node, b::Node)\n\nCompare two AST nodes for structural equality. Ignores source positions and parser state, comparing only the semantic content: container types, literals, and tree structure.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.available_columns-Tuple{CommonMark.Writer{CommonMark.Term}}","page":"API Reference","title":"CommonMark.available_columns","text":"Given the current indent of the renderer we check to see how much space is left on the current line.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.container_equal-Union{Tuple{T}, Tuple{T, T}} where T<:CommonMark.AbstractContainer","page":"API Reference","title":"CommonMark.container_equal","text":"container_equal(a::AbstractContainer, b::AbstractContainer)\n\nCompare two container types for equality, checking type and all fields.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.disable!-Tuple{CommonMark.AbstractParser, Union{Tuple, Vector}}","page":"API Reference","title":"CommonMark.disable!","text":"disable!(parser, rule)\ndisable!(parser, rules)\n\nDisable a parsing rule or collection of rules from the parser.\n\nThis removes the specified rules and re-enables all remaining rules. Useful for removing default CommonMark behavior.\n\nReturns the parser for method chaining.\n\nExamples\n\np = Parser()\ndisable!(p, SetextHeadingRule())  # Only allow ATX-style headings\ndisable!(p, [HtmlBlockRule(), HtmlInlineRule()])  # Disable raw HTML\n\nSee also: enable!, Parser\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.enable!-Tuple{CommonMark.AbstractParser, Any}","page":"API Reference","title":"CommonMark.enable!","text":"enable!(parser, rule)\nenable!(parser, rules)\n\nEnable a parsing rule or collection of rules in the parser.\n\nRules can be core CommonMark rules (e.g., AtxHeadingRule) or extension rules (e.g., TableRule, AdmonitionRule).\n\nReturns the parser for method chaining.\n\nExamples\n\np = Parser()\nenable!(p, TableRule())\nenable!(p, [FootnoteRule(), AdmonitionRule()])\n\nSee also: disable!, Parser\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.finalize_literal!-Tuple{CommonMark.Node}","page":"API Reference","title":"CommonMark.finalize_literal!","text":"Finalize literal from buffer, converting IOBuffer to String.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.frontmatter-Tuple{CommonMark.Node}","page":"API Reference","title":"CommonMark.frontmatter","text":"frontmatter(ast::Node) -> Dict{String,Any}\n\nExtract front matter data from a parsed document.\n\nReturns an empty dictionary if no front matter is present. Requires FrontMatterRule to be enabled during parsing. Supports YAML (---), TOML (+++), and JSON (;;;) delimiters.\n\nExamples\n\np = Parser()\nenable!(p, FrontMatterRule(yaml=YAML.load))\nast = p(\"\"\"\n---\ntitle: My Document\nauthor: Jane Doe\n---\n# Content\n\"\"\")\nfrontmatter(ast)  # Dict(\"title\" => \"My Document\", \"author\" => \"Jane Doe\")\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.getmeta-Tuple{CommonMark.Node, Any, Any}","page":"API Reference","title":"CommonMark.getmeta","text":"Get meta value without allocating if meta is nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.hasmeta-Tuple{CommonMark.Node, Any}","page":"API Reference","title":"CommonMark.hasmeta","text":"Check if meta has key without allocating if meta is nothing.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.html-Tuple","page":"API Reference","title":"CommonMark.html","text":"html(ast::Node) -> String\nhtml(filename::String, ast::Node)\nhtml(io::IO, ast::Node)\n\nRender a CommonMark AST to HTML.\n\nKeyword Arguments\n\nsoftbreak::String = \"\\n\": String to use for soft line breaks\nsafe::Bool = false: Escape potentially unsafe HTML content\nsourcepos::Bool = false: Include source position data attributes\n\nExamples\n\np = Parser()\nast = p(\"# Hello\\n\\nWorld\")\nhtml(ast)  # \"<h1>Hello</h1>\\n<p>World</p>\\n\"\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.latex-Tuple","page":"API Reference","title":"CommonMark.latex","text":"latex(ast::Node) -> String\nlatex(filename::String, ast::Node)\nlatex(io::IO, ast::Node)\n\nRender a CommonMark AST to LaTeX.\n\nExamples\n\np = Parser()\nast = p(\"# Hello\\n\\nWorld\")\nlatex(ast)  # \"\\\\section{Hello}\\n\\nWorld\\n\"\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.literal_width-Tuple{CommonMark.Node}","page":"API Reference","title":"CommonMark.literal_width","text":"What is the width of the literal text stored in node and all of it's child nodes. Used to determine alignment for rendering nodes such as centered.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.markdown-Tuple","page":"API Reference","title":"CommonMark.markdown","text":"markdown(ast::Node) -> String\nmarkdown(filename::String, ast::Node)\nmarkdown(io::IO, ast::Node)\n\nRender a CommonMark AST back to Markdown text.\n\nUseful for normalizing Markdown formatting or for roundtrip testing. Output uses opinionated formatting with no trailing whitespace.\n\nExamples\n\np = Parser()\nast = p(\"# Hello\\n\\nWorld\")\nmarkdown(ast)  # \"# Hello\\n\\nWorld\\n\"\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.mergemeta!-Tuple{CommonMark.Node, AbstractDict}","page":"API Reference","title":"CommonMark.mergemeta!","text":"Merge dict into meta, initializing if needed.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.notebook-Tuple","page":"API Reference","title":"CommonMark.notebook","text":"notebook(ast::Node) -> String\nnotebook(filename::String, ast::Node)\nnotebook(io::IO, ast::Node)\n\nRender a CommonMark AST to a Jupyter notebook (.ipynb format).\n\nCode blocks are converted to code cells, and other content becomes Markdown cells.\n\nExamples\n\np = Parser()\nast = p(\"# Title\\n\\n```julia\\nprintln(\\\"Hello\\\")\\n```\")\nnotebook(\"output.ipynb\", ast)\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.print_literal-Tuple{CommonMark.Writer{CommonMark.Term}, Vararg{Any}}","page":"API Reference","title":"CommonMark.print_literal","text":"Literal printing of a of parts. Behaviour depends on when .wrap is active at the moment, which is set in Paragraph rendering.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.print_margin-Tuple{CommonMark.Writer}","page":"API Reference","title":"CommonMark.print_margin","text":"Print out all the current segments present in the margin buffer.\n\nEach time a segment gets printed it's count is reduced. When a segment has a count of zero it won't be printed and instead spaces equal to it's width are printed. For persistent printing a count of -1 should be used.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.push_margin!","page":"API Reference","title":"CommonMark.push_margin!","text":"Adds a new segment to the margin buffer, but will only print out for the given number of count calls to print_margin. After count calls it will instead print out spaces equal to the width of text.\n\n\n\n\n\n","category":"function"},{"location":"api/#CommonMark.push_margin!-2","page":"API Reference","title":"CommonMark.push_margin!","text":"Adds a new segment to the margin buffer. This segment is persistent and thus will print on every margin print.\n\n\n\n\n\n","category":"function"},{"location":"api/#CommonMark.push_margin!-Tuple{CommonMark.Writer, Integer, AbstractString, AbstractString}","page":"API Reference","title":"CommonMark.push_margin!","text":"Adds new segmant to the margin buffer. count determines how many time initial is printed. After that, the width of rest is printed instead.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.setmeta!-Tuple{CommonMark.Node, Any, Any}","page":"API Reference","title":"CommonMark.setmeta!","text":"Set meta value, initializing dict if needed.\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.term-Tuple","page":"API Reference","title":"CommonMark.term","text":"term(ast::Node) -> String\nterm(filename::String, ast::Node)\nterm(io::IO, ast::Node)\n\nRender a CommonMark AST for terminal display with ANSI formatting.\n\nIncludes colored syntax highlighting for code blocks when a highlighter is configured.\n\nExamples\n\np = Parser()\nast = p(\"# Hello\\n\\n**World**\")\nterm(ast)  # Returns ANSI-formatted string\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.typst-Tuple","page":"API Reference","title":"CommonMark.typst","text":"typst(ast::Node) -> String\ntypst(filename::String, ast::Node)\ntypst(io::IO, ast::Node)\n\nRender a CommonMark AST to Typst markup.\n\nExamples\n\np = Parser()\nast = p(\"# Hello\\n\\nWorld\")\ntypst(ast)\n\n\n\n\n\n","category":"method"},{"location":"api/#CommonMark.@cm_str","page":"API Reference","title":"CommonMark.@cm_str","text":"cm\"\"\n\nA string macro for markdown text that implements standard string interpolation. Returns a parsed markdown AST with the values of the interpolation expressions embedded in the AST.\n\nvalue = \"interpolated\"\ncm\"Some *$(value)* text.\"\n\nThe default syntax rules used for parsing are:\n\nAdmonitionRule\nAttributeRule\nAutoIdentifierRule\nCitationRule\nFootnoteRule\nMathRule\nRawContentRule\nTableRule\nTypographyRule\n\nwhich matches closely with the default syntax supported in Markdown.@md_str.\n\ninfo: Info\nThe DollarMathRule is not enabled since it conflicts with the interpolation syntax. Use double backticks and math language literal blocks for maths that is provided by the MathRule.\n\nA custom Parser can be invoked when using cm\"\" by providing a suffix to the macro call, for example:\n\nmore = \"more\"\ncm\"Some **$(uppercase(more))** text.\"none\n\nwhere the suffixed none will invoke a basic Parser with no additional syntax rules enabled!. To use your own custom parser, for example to only enable the TypographyRule, you can suffix the call with a named function from the current module's global scope that returns the Parser object with the required rules enabled:\n\ncustom() = enable!(Parser(), TypographyRule())\n\nIt can then be used as\n\nstr = \"custom\"\ncm\"A '$(titlecase(str))' parser...\"custom\n\n\n\n\n\n","category":"macro"},{"location":"core/#Core-Rules","page":"Core Rules","title":"Core Rules","text":"These rules are enabled by default in Parser() and implement the CommonMark specification. They cover the standard markdown syntax that most users expect.\n\nusing CommonMark\nparser = Parser()\nnothing # hide","category":"section"},{"location":"core/#Block-Rules","page":"Core Rules","title":"Block Rules","text":"Block rules handle document structure: headings, paragraphs, lists, code blocks, and other elements that occupy their own lines.","category":"section"},{"location":"core/#ATX-Headings","page":"Core Rules","title":"ATX Headings","text":"Headings prefixed with # characters. Supports levels 1-6.\n\nast = parser(\"# Heading 1\\n## Heading 2\\n### Heading 3\")\nhtml(ast)","category":"section"},{"location":"core/#Setext-Headings","page":"Core Rules","title":"Setext Headings","text":"Headings underlined with = or -. Only supports levels 1 and 2.\n\nast = parser(\"Heading 1\\n=========\\n\\nHeading 2\\n---------\")\nhtml(ast)","category":"section"},{"location":"core/#Block-Quotes","page":"Core Rules","title":"Block Quotes","text":"Quoted text prefixed with >. Can be nested and contain other block elements.\n\nast = parser(\"> This is a block quote.\\n> It can span multiple lines.\")\nhtml(ast)","category":"section"},{"location":"core/#Lists","page":"Core Rules","title":"Lists","text":"Unordered lists use -, +, or * as markers:\n\nast = parser(\"- Item one\\n- Item two\\n- Item three\")\nhtml(ast)\n\nOrdered lists use numbers followed by . or ):\n\nast = parser(\"1. First item\\n2. Second item\\n3. Third item\")\nhtml(ast)\n\nLists can be nested by indenting items, and can contain multiple paragraphs or other block elements.","category":"section"},{"location":"core/#Fenced-Code-Blocks","page":"Core Rules","title":"Fenced Code Blocks","text":"Code blocks delimited by triple backticks or tildes. An optional info string specifies the language for syntax highlighting.\n\nast = parser(\"\"\"\n```julia\nprintln(\"Hello, World!\")\n```\n\"\"\")\nhtml(ast)","category":"section"},{"location":"core/#Indented-Code-Blocks","page":"Core Rules","title":"Indented Code Blocks","text":"Code indented by at least 4 spaces. No language info string is possible.\n\nast = parser(\"    function hello()\\n        println(\\\"Hello\\\")\\n    end\")\nhtml(ast)","category":"section"},{"location":"core/#HTML-Blocks","page":"Core Rules","title":"HTML Blocks","text":"Raw HTML that passes through unchanged. Useful for embedding content that markdown can't express.\n\nast = parser(\"<div class=\\\"custom\\\">\\n  Raw HTML content.\\n</div>\")\nhtml(ast)","category":"section"},{"location":"core/#Thematic-Breaks","page":"Core Rules","title":"Thematic Breaks","text":"Horizontal rules created with three or more -, *, or _ characters.\n\nast = parser(\"Above\\n\\n---\\n\\nBelow\")\nhtml(ast)","category":"section"},{"location":"core/#Inline-Rules","page":"Core Rules","title":"Inline Rules","text":"Inline rules handle formatting within paragraphs: emphasis, links, code spans, and other elements that flow with text.","category":"section"},{"location":"core/#Emphasis","page":"Core Rules","title":"Emphasis","text":"Asterisks and underscores create emphasis. Single delimiters produce <em>, double delimiters produce <strong>.\n\nast = parser(\"*italic* and **bold** and ***both***\")\nhtml(ast)\n\nast = parser(\"_italic_ and __bold__ and ___both___\")\nhtml(ast)","category":"section"},{"location":"core/#Inline-Code","page":"Core Rules","title":"Inline Code","text":"Backticks create code spans. Use multiple backticks to include literal backticks.\n\nast = parser(\"Use `code` for inline code.\")\nhtml(ast)","category":"section"},{"location":"core/#Links","page":"Core Rules","title":"Links","text":"Inline links with the URL in parentheses, or reference links defined elsewhere.\n\nast = parser(\"[inline link](https://example.com)\")\nhtml(ast)\n\nReference-style links separate the URL from the text, useful for keeping paragraphs readable or reusing the same URL multiple times.","category":"section"},{"location":"core/#Images","page":"Core Rules","title":"Images","text":"Same syntax as links but prefixed with !. The link text becomes alt text.\n\nast = parser(\"![alt text](image.png)\")\nhtml(ast)","category":"section"},{"location":"core/#Autolinks","page":"Core Rules","title":"Autolinks","text":"URLs and email addresses in angle brackets become clickable links automatically.\n\nast = parser(\"<https://example.com>\")\nhtml(ast)","category":"section"},{"location":"core/#HTML-Inline","page":"Core Rules","title":"HTML Inline","text":"Raw HTML tags within paragraphs pass through unchanged.\n\nast = parser(\"This has <em>inline HTML</em> content.\")\nhtml(ast)","category":"section"},{"location":"core/#HTML-Entities","page":"Core Rules","title":"HTML Entities","text":"Named and numeric HTML entities are decoded.\n\nast = parser(\"&amp; &copy; &mdash;\")\nhtml(ast)","category":"section"},{"location":"core/#Disabling-Default-Rules","page":"Core Rules","title":"Disabling Default Rules","text":"Use disable! to turn off rules you don't want. This is useful for stricter parsing or when certain syntax conflicts with your content.\n\np = Parser()\ndisable!(p, SetextHeadingRule())  # Only ATX headings\ndisable!(p, [HtmlBlockRule(), HtmlInlineRule()])  # No raw HTML\nnothing # hide","category":"section"},{"location":"developing/#Developing-Extensions","page":"Developing Extensions","title":"Developing Extensions","text":"warning: Internal API\nThis documents internal interfaces not covered by semantic versioning. These APIs may change between any versions without notice.\n\nThis page documents how to create custom parsing rules for CommonMark.jl. An extension consists of three parts: AST node types, parsing rules, and writer functions.\n\nusing CommonMark\nnothing # hide","category":"section"},{"location":"developing/#AST-Nodes","page":"Developing Extensions","title":"AST Nodes","text":"","category":"section"},{"location":"developing/#Type-Hierarchy","page":"Developing Extensions","title":"Type Hierarchy","text":"All node types inherit from AbstractContainer:\n\nabstract type AbstractContainer end\nabstract type AbstractBlock <: AbstractContainer end   # Block-level elements\nabstract type AbstractInline <: AbstractContainer end  # Inline elements\n\nDefine your node type as a struct:\n\nstruct MyBlock <: AbstractBlock\n    info::String  # Store any data your extension needs\nend\n\nstruct MyInline <: AbstractInline end","category":"section"},{"location":"developing/#The-Node-Struct","page":"Developing Extensions","title":"The Node Struct","text":"Nodes wrap your container type in a tree structure:\n\nmutable struct Node\n    t::AbstractContainer      # Your container type (MyBlock, MyInline, etc.)\n    parent::Node              # Parent node\n    first_child::Node         # First child\n    last_child::Node          # Last child\n    prv::Node                 # Previous sibling\n    nxt::Node                 # Next sibling\n    sourcepos::SourcePos      # Source position ((start_line, start_col), (end_line, end_col))\n    literal::String           # Text content (for leaf nodes)\n    meta::Dict{String,Any}    # Arbitrary metadata\nend\n\nUse isnull(node) to check for null references (rather than checking against nothing).","category":"section"},{"location":"developing/#Container-Behavior-Methods","page":"Developing Extensions","title":"Container Behavior Methods","text":"Define these methods to control how your node participates in parsing:\n\n# Can this node contain children? Default: false\nis_container(::MyBlock) = true\n\n# Does this block accept raw text lines? (like code blocks)\naccepts_lines(::MyBlock) = false\n\n# Which child types are allowed? Default allows most types.\ncan_contain(::MyBlock, child) = !(child isa Item)\n\n# Called when the block is closed. Default: nothing\nfinalize(::MyBlock, parser::Parser, node::Node) = nothing\n\n# Called to check if this block continues on the next line.\n# Return: 0 = continue, 1 = close block, 2 = close and skip line\nfunction continue_(::MyBlock, parser::Parser, node::Node)\n    if parser.indent >= 4\n        advance_offset(parser, 4, true)\n        return 0  # Continue this block\n    elseif parser.blank\n        advance_next_nonspace(parser)\n        return 0\n    else\n        return 1  # Close this block\n    end\nend","category":"section"},{"location":"developing/#Rule-Interface","page":"Developing Extensions","title":"Rule Interface","text":"","category":"section"},{"location":"developing/#The-Rule-Struct","page":"Developing Extensions","title":"The Rule Struct","text":"Rules wrap parsing functions with metadata:\n\nstruct Rule\n    fn::Function       # The parsing function\n    priority::Float64  # Lower priority runs first\n    triggers::String   # Trigger characters (empty = all positions)\nend\n\nRule(fn, priority, triggers = \"\")\n\nCreate rules with do-block syntax:\n\nblock_rule(::MyRule) = Rule(0.5, \"!\") do parser, container\n    # Parse logic here\n    return 0\nend","category":"section"},{"location":"developing/#Rule-Hooks","page":"Developing Extensions","title":"Rule Hooks","text":"Define these methods on your rule type to register parsing functions:\n\nHook Purpose Signature\nblock_rule Parse block-level syntax (parser, container) → 0/1/2\ninline_rule Parse inline syntax (parser, block) → Bool\nblock_modifier Transform blocks after parsing (parser, block) → nothing\ninline_modifier Transform inlines after parsing (parser, block) → nothing\n\nAll hooks return nothing by default (no rule registered).","category":"section"},{"location":"developing/#Block-Rule-Return-Values","page":"Developing Extensions","title":"Block Rule Return Values","text":"Value Meaning\n0 No match\n1 Matched container (keeps parsing children)\n2 Matched leaf block (stops block parsing)","category":"section"},{"location":"developing/#Inline-Rule-Return-Values","page":"Developing Extensions","title":"Inline Rule Return Values","text":"Value Meaning\nfalse No match, try next rule\ntrue Matched and consumed input","category":"section"},{"location":"developing/#Delimiter-Hooks","page":"Developing Extensions","title":"Delimiter Hooks","text":"For emphasis-like syntax (paired delimiters like ~~text~~), use these hooks instead of writing custom inline parsing:\n\n# Map (character, count) to node type\ndelim_nodes(::MyRule) = Dict(('~', 2) => Strikethrough)\n\n# Define flanking behavior: :standard, :underscore, or :permissive\nflanking_rule(::MyRule) = ('~', :standard)\n\n# Optional: characters that use odd-match logic\nuses_odd_match(::MyRule) = '~'\n\nWhen using delimiter hooks, your inline_rule should call handle_delim:\n\ninline_rule(::MyRule) = Rule(1, \"~\") do parser, block\n    handle_delim(parser, '~', block)\nend\ninline_modifier(::MyRule) = Rule(process_emphasis, 1)","category":"section"},{"location":"developing/#Writer-Functions","page":"Developing Extensions","title":"Writer Functions","text":"","category":"section"},{"location":"developing/#Signature","page":"Developing Extensions","title":"Signature","text":"Implement a writer for each output format:\n\nfunction write_html(::MyBlock, renderer, node, enter)\n    if enter\n        tag(renderer, \"div\", attributes(renderer, node, [\"class\" => \"my-block\"]))\n    else\n        tag(renderer, \"/div\")\n    end\nend\n\nThe enter parameter is true when entering the node, false when leaving. This allows generating opening/closing tags for containers.","category":"section"},{"location":"developing/#Required-Writers","page":"Developing Extensions","title":"Required Writers","text":"Function Output Format\nwrite_html HTML\nwrite_latex LaTeX\nwrite_typst Typst\nwrite_term Terminal (ANSI)\nwrite_markdown Markdown (roundtrip)","category":"section"},{"location":"developing/#Writer-Utilities","page":"Developing Extensions","title":"Writer Utilities","text":"HTML:\n\ntag(w, name, attrs=[]) - emit HTML tag\nattributes(w, node, extra=[]) - format attributes from node.meta\n\nAll formats:\n\nliteral(w, str...) - emit raw text\ncr(w) - conditional newline (if not at line start)\nprint(w.buffer, str) - direct buffer access\n\nTerminal/Markdown:\n\npush_margin!(w, prefix) - add indentation prefix\npop_margin!(w) - remove indentation prefix\nprint_margin(w) - emit current margin\n\nTerminal:\n\nprint_literal(w, crayon, text, inv(crayon)) - styled output","category":"section"},{"location":"developing/#Parser-State","page":"Developing Extensions","title":"Parser State","text":"Key parser fields available during block parsing:\n\nparser.indent            # Current indentation level\nparser.indented          # Is line indented >= 4 spaces?\nparser.blank             # Is current line blank?\nparser.next_nonspace     # Position of next non-whitespace\nparser.line_number       # Current line number\n\n# Utility functions\nrest_from_nonspace(parser)      # Get remaining line from next non-space\nadvance_offset(parser, n, cols) # Advance position by n chars\nadvance_next_nonspace(parser)   # Move to next non-space\nadvance_to_end(parser)          # Consume rest of line\nclose_unmatched_blocks(parser)  # Finalize pending blocks\nadd_child(parser, type, offset) # Create new child node\n\nFor inline parsing:\n\ntrypeek(parser, Char)           # Peek current character\nconsume(parser, match)          # Consume regex match\nappend_child(block, node)       # Add inline child","category":"section"},{"location":"developing/#Registration","page":"Developing Extensions","title":"Registration","text":"Enable your rule with enable!:\n\nparser = Parser()\nenable!(parser, MyRule())\n\nRules can be disabled with disable!:\n\ndisable!(parser, SetextHeadingRule())  # Only allow ATX headings","category":"section"},{"location":"developing/#Example:-Highlight-(Inline)","page":"Developing Extensions","title":"Example: Highlight (Inline)","text":"A custom inline extension using delimiter hooks for ==highlighted text== syntax.\n\n# AST node\nstruct Highlight <: CommonMark.AbstractInline end\nCommonMark.is_container(::Highlight) = true\n\n# Rule type\nstruct HighlightRule end\n\n# Use delimiter infrastructure for ==text== parsing\nCommonMark.inline_rule(::HighlightRule) = CommonMark.Rule(1, \"=\") do parser, block\n    CommonMark.handle_delim(parser, '=', block)\nend\nCommonMark.inline_modifier(::HighlightRule) = CommonMark.Rule(CommonMark.process_emphasis, 1)\nCommonMark.delim_nodes(::HighlightRule) = Dict(('=', 2) => Highlight)\nCommonMark.flanking_rule(::HighlightRule) = ('=', :standard)\n\n# Writers\nCommonMark.write_html(::Highlight, r, n, ent) =\n    CommonMark.tag(r, ent ? \"mark\" : \"/mark\", ent ? CommonMark.attributes(r, n) : [])\n\nCommonMark.write_latex(::Highlight, w, n, ent) =\n    print(w.buffer, ent ? \"\\\\hl{\" : \"}\")\n\nCommonMark.write_term(::Highlight, w, n, ent) = nothing  # No terminal styling\n\nCommonMark.write_markdown(::Highlight, w, n, ent) = CommonMark.literal(w, \"==\")\nnothing # hide\n\nUsage:\n\nparser = Parser()\nenable!(parser, HighlightRule())\nast = parser(\"Some ==highlighted text== here.\")\nhtml(ast)","category":"section"},{"location":"developing/#Example:-Spoiler-Block","page":"Developing Extensions","title":"Example: Spoiler Block","text":"A custom block extension for spoiler/collapsible content using ??? title syntax.\n\n# AST node with title field\nstruct Spoiler <: CommonMark.AbstractBlock\n    title::String\nend\n\n# Container behavior\nCommonMark.is_container(::Spoiler) = true\nCommonMark.accepts_lines(::Spoiler) = false\nCommonMark.can_contain(::Spoiler, t) = !(t isa CommonMark.Item)\nCommonMark.finalize(::Spoiler, ::CommonMark.Parser, ::CommonMark.Node) = nothing\n\n# Continue if indented by 4 spaces or blank\nfunction CommonMark.continue_(::Spoiler, parser::CommonMark.Parser, ::CommonMark.Node)\n    if parser.indent >= 4\n        CommonMark.advance_offset(parser, 4, true)\n        return 0  # Continue\n    elseif parser.blank\n        CommonMark.advance_next_nonspace(parser)\n        return 0\n    else\n        return 1  # Close\n    end\nend\n\n# Rule type\nstruct SpoilerRule end\n\n# Block parsing function\nCommonMark.block_rule(::SpoilerRule) = CommonMark.Rule(0.5, \"?\") do parser, container\n    if !parser.indented\n        ln = CommonMark.rest_from_nonspace(parser)\n        m = match(r\"^\\?\\?\\? (.+)$\", ln)\n        if m !== nothing\n            CommonMark.close_unmatched_blocks(parser)\n            CommonMark.add_child(parser, Spoiler(m[1]), parser.next_nonspace)\n            CommonMark.advance_to_end(parser)\n            return 1  # Container block\n        end\n    end\n    return 0\nend\n\n# Writers\nfunction CommonMark.write_html(s::Spoiler, rend, node, enter)\n    if enter\n        CommonMark.tag(rend, \"details\", CommonMark.attributes(rend, node))\n        CommonMark.tag(rend, \"summary\")\n        print(rend.buffer, s.title)\n        CommonMark.tag(rend, \"/summary\")\n    else\n        CommonMark.tag(rend, \"/details\")\n    end\nend\n\nCommonMark.write_latex(s::Spoiler, w, n, ent) =\n    CommonMark.literal(w, ent ? \"\\\\begin{spoiler}{$(s.title)}\\n\" : \"\\\\end{spoiler}\\n\")\n\nCommonMark.write_term(::Spoiler, w, n, ent) = nothing\n\nfunction CommonMark.write_markdown(s::Spoiler, w, node, ent)\n    if ent\n        CommonMark.push_margin!(w, \"    \")\n        CommonMark.literal(w, \"??? \", s.title, \"\\n\")\n        CommonMark.print_margin(w)\n        CommonMark.literal(w, \"\\n\")\n    else\n        CommonMark.pop_margin!(w)\n        CommonMark.cr(w)\n    end\nend\nnothing # hide\n\nUsage:\n\nparser = Parser()\nenable!(parser, SpoilerRule())\nast = parser(\"\"\"\n??? Click to reveal\n    This content is hidden by default.\n    It can contain **formatted** text.\n\"\"\")\nhtml(ast)","category":"section"},{"location":"developing/#Extension-Patterns","page":"Developing Extensions","title":"Extension Patterns","text":"","category":"section"},{"location":"developing/#Block-Modifier","page":"Developing Extensions","title":"Block Modifier","text":"Transform existing nodes without custom parsing. Useful for detecting patterns in parsed content:\n\nblock_modifier(::MyRule) = Rule(50) do parser, block\n    if block.t isa Paragraph\n        # Check content and transform if needed\n        m = match(r\"^pattern\", block.literal)\n        if m !== nothing\n            block.t = MyCustomType()\n        end\n    end\nend\n\nSee GitHubAlertRule and TaskListRule for examples.","category":"section"},{"location":"developing/#Stateful-Rules","page":"Developing Extensions","title":"Stateful Rules","text":"Store state during parsing for cross-referencing:\n\nstruct FootnoteRule\n    cache::Dict{String,Node}\n    FootnoteRule() = new(Dict())\nend\n\nblock_rule(fr::FootnoteRule) = Rule(0.5, \"[\") do parser, container\n    # Store definitions in cache\n    fr.cache[id] = node\nend\n\ninline_rule(fr::FootnoteRule) = Rule(0.5, \"[\") do parser, block\n    # Reference cache to link footnotes\n    def = get(fr.cache, id, nothing)\nend","category":"section"},{"location":"#CommonMark.jl","page":"Home","title":"CommonMark.jl","text":"A CommonMark-compliant parser for Julia.","category":"section"},{"location":"#Features","page":"Home","title":"Features","text":"Spec compliant: Passes the CommonMark spec test suite\nMultiple outputs: HTML, LaTeX, Typst, terminal (ANSI), Jupyter notebooks\nMarkdown roundtrip: Parse and re-emit normalized markdown\nModular parser: Enable/disable individual syntax rules\nExtensions: Tables, footnotes, math, front matter, admonitions, and more","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"CommonMark\")","category":"section"},{"location":"#Quick-Start","page":"Home","title":"Quick Start","text":"Create a parser, parse some markdown, and render it to HTML:\n\nusing CommonMark\n\nparser = Parser()\nast = parser(\"Hello *world*\")\nhtml(ast)\n\nThe parser returns an abstract syntax tree (AST) that can be rendered to multiple output formats or inspected programmatically.","category":"section"},{"location":"#Parsing","page":"Home","title":"Parsing","text":"The parser is callable on strings:\n\nast = parser(\"# Heading\\n\\nParagraph\")\nhtml(ast)\n\nFor files, use open with the parser:\n\nast = open(parser, \"document.md\")","category":"section"},{"location":"#Output-Formats","page":"Home","title":"Output Formats","text":"The same AST can be rendered to different formats. Each format has its own writer function that returns a string or writes to a file/IO.\n\nast = parser(\"# Title\\n\\n**Bold** and *italic*.\")\nnothing # hide\n\nHTML for web pages:\n\nhtml(ast)\n\nLaTeX for documents and papers:\n\nlatex(ast)\n\nMarkdown for normalization and roundtripping:\n\nmarkdown(ast)\n\nOther formats include typst() for Typst documents, term() for terminal output with ANSI colors, and notebook() for Jupyter notebooks.\n\nAll writer functions accept a filename or IO as the first argument:\n\nhtml(\"output.html\", ast)\nterm(stdout, ast)","category":"section"},{"location":"#Customization","page":"Home","title":"Customization","text":"The parser is modular. Each piece of syntax (headings, lists, emphasis, etc.) is handled by a rule that can be enabled or disabled independently.\n\nBy default, all standard CommonMark syntax is enabled. Extensions add syntax beyond the spec:\n\nusing CommonMark\n\nparser = Parser()\nenable!(parser, TableRule())\nenable!(parser, FootnoteRule())\nenable!(parser, MathRule())\n\nast = parser(\"\"\"\n| A | B |\n|---|---|\n| 1 | 2 |\n\"\"\")\nhtml(ast)\n\nDefault rules can be disabled if you want stricter or simpler parsing:\n\nparser = Parser()\ndisable!(parser, SetextHeadingRule())  # Only allow # headings, not underlined\nnothing # hide\n\nSee Core Rules for the default syntax and Extensions for additional features like tables, math, and admonitions.","category":"section"},{"location":"extensions/#extensions-page","page":"Extensions","title":"Extensions","text":"Extensions add syntax beyond the CommonMark specification. They must be explicitly enabled with enable!.\n\nusing CommonMark\nnothing # hide","category":"section"},{"location":"extensions/#Tables","page":"Extensions","title":"Tables","text":"Pipe-style tables from GitHub Flavored Markdown. Tables require a header row and a separator row that defines column alignment.\n\nparser = Parser()\nenable!(parser, TableRule())\n\nast = parser(\"\"\"\n| Column One | Column Two | Column Three |\n|:---------- | ---------- |:------------:|\n| Row `1`    | Column `2` |              |\n| *Row* 2    | **Row** 2  | Column 3     |\n\"\"\")\nhtml(ast)\n\nAlignment is set with colons in the separator: :--- left, ---: right, :---: center. Cells can contain inline formatting. Escape literal pipes with backslashes.","category":"section"},{"location":"extensions/#Admonitions","page":"Extensions","title":"Admonitions","text":"Callout boxes for notes, warnings, tips, and other highlighted content. Common in technical documentation.\n\nparser = Parser()\nenable!(parser, AdmonitionRule())\n\nast = parser(\"\"\"\n!!! note \"Custom Title\"\n    This is an admonition block.\n\n!!! warning\n    Title defaults to category name.\n\"\"\")\nhtml(ast)\n\nThe category (note, warning, tip, etc.) determines styling. An optional quoted string overrides the title. Content must be indented by 4 spaces.","category":"section"},{"location":"extensions/#Footnotes","page":"Extensions","title":"Footnotes","text":"Reference-style footnotes that collect at the end of the document. Useful for citations, asides, and additional context without interrupting flow.\n\nparser = Parser()\nenable!(parser, FootnoteRule())\n\nast = parser(\"\"\"\nHere is a footnote reference[^1].\n\n[^1]: This is the footnote content.\n\"\"\")\nhtml(ast)\n\nFootnote identifiers can be any word or number. Definitions can appear anywhere in the document and will be collected at the end.","category":"section"},{"location":"extensions/#Typography","page":"Extensions","title":"Typography","text":"Converts ASCII punctuation to proper typographic characters. Makes documents look more polished without requiring special input.\n\nparser = Parser()\nenable!(parser, TypographyRule())\n\nast = parser(\"\\\"Hello\\\" -- Pro tip... use 'single quotes' too --- or not.\")\nhtml(ast)\n\nConversions: straight quotes to curly quotes, ... to ellipsis, -- to en-dash, --- to em-dash. Disable specific conversions with keyword arguments:\n\nenable!(parser, TypographyRule(double_quotes=false, dashes=false))","category":"section"},{"location":"extensions/#Math","page":"Extensions","title":"Math","text":"LaTeX math expressions for technical and scientific documents.","category":"section"},{"location":"extensions/#Julia-style-(double-backticks)","page":"Extensions","title":"Julia-style (double backticks)","text":"Uses double backticks for inline math, matching Julia's docstring convention. Display math uses fenced code blocks with math as the language.\n\nparser = Parser()\nenable!(parser, MathRule())\n\nast = parser(\"Inline ``E = mc^2`` math.\")\nhtml(ast)\n\nDisplay math with fenced blocks:\n\nast = parser(\"\"\"\n```math\n\\\\int_0^\\\\infty e^{-x^2} dx\n```\n\"\"\")\nhtml(ast)","category":"section"},{"location":"extensions/#Dollar-style","page":"Extensions","title":"Dollar-style","text":"Traditional LaTeX syntax with single $ for inline and double $$ for display. More familiar to users coming from LaTeX or other markdown flavors.\n\nparser = Parser()\nenable!(parser, DollarMathRule())\n\nast = parser(\"Inline \\$E = mc^2\\$ math.\")\nhtml(ast)","category":"section"},{"location":"extensions/#Attributes","page":"Extensions","title":"Attributes","text":"Attach IDs, classes, and arbitrary key-value pairs to elements. Useful for styling, linking, and integrating with JavaScript.\n\nparser = Parser()\nenable!(parser, AttributeRule())\n\nast = parser(\"\"\"\n{#my-id .highlight}\n# Heading\n\"\"\")\nhtml(ast)\n\nBlock attributes go above the target element. Inline attributes go after:\n\nast = parser(\"*text*{.important}\")\nhtml(ast)\n\nCSS shorthand: #foo expands to id=\"foo\", .bar expands to class=\"bar\".","category":"section"},{"location":"extensions/#Strikethrough","page":"Extensions","title":"Strikethrough","text":"Marks deleted or outdated text. Renders as <del> in HTML.\n\nparser = Parser()\nenable!(parser, StrikethroughRule())\n\nast = parser(\"~~deleted text~~\")\nhtml(ast)","category":"section"},{"location":"extensions/#Subscript","page":"Extensions","title":"Subscript","text":"Chemical formulas, mathematical notation, and other subscripted text.\n\nparser = Parser()\nenable!(parser, SubscriptRule())\n\nast = parser(\"H~2~O\")\nhtml(ast)\n\nCan be combined with StrikethroughRule since they use different tilde counts (single vs double).","category":"section"},{"location":"extensions/#Superscript","page":"Extensions","title":"Superscript","text":"Exponents, ordinals, and other superscripted text.\n\nparser = Parser()\nenable!(parser, SuperscriptRule())\n\nast = parser(\"x^2^\")\nhtml(ast)","category":"section"},{"location":"extensions/#Task-Lists","page":"Extensions","title":"Task Lists","text":"Interactive checklists from GitHub Flavored Markdown. Useful for todo lists and progress tracking.\n\nparser = Parser()\nenable!(parser, TaskListRule())\n\nast = parser(\"\"\"\n- [ ] Unchecked\n- [x] Checked\n\"\"\")\nhtml(ast)","category":"section"},{"location":"extensions/#GitHub-Alerts","page":"Extensions","title":"GitHub Alerts","text":"Styled callouts matching GitHub's markdown alerts. Similar to admonitions but with GitHub's specific syntax and categories.\n\nparser = Parser()\nenable!(parser, GitHubAlertRule())\n\nast = parser(\"\"\"\n> [!NOTE]\n> Useful information.\n\n> [!WARNING]\n> Important warning.\n\"\"\")\nhtml(ast)\n\nSupported types: NOTE, TIP, IMPORTANT, WARNING, CAUTION.","category":"section"},{"location":"extensions/#Fenced-Divs","page":"Extensions","title":"Fenced Divs","text":"Generic containers from Pandoc. Wrap arbitrary content in a div with classes and attributes. Useful for custom styling and semantic markup.\n\nparser = Parser()\nenable!(parser, FencedDivRule())\n\nast = parser(\"\"\"\n::: warning\nThis is a warning.\n:::\n\"\"\")\nhtml(ast)\n\nDivs can be nested by using more colons for outer fences.","category":"section"},{"location":"extensions/#Front-Matter","page":"Extensions","title":"Front Matter","text":"Structured metadata at the start of a document. Commonly used for titles, authors, dates, and configuration in static site generators.\n\nusing YAML\n\nparser = Parser()\nenable!(parser, FrontMatterRule(yaml=YAML.load))\n\nast = parser(\"\"\"\n---\ntitle: My Document\nauthor: Jane Doe\n---\n\nContent here.\n\"\"\")\nfrontmatter(ast)\n\nDelimiters determine format: --- for YAML, +++ for TOML, ;;; for JSON. Pass the appropriate parser function for each format you want to support.","category":"section"},{"location":"extensions/#Citations","page":"Extensions","title":"Citations","text":"Academic-style citations with Pandoc syntax. Requires bibliography data to be passed to the writer.\n\nenable!(parser, CitationRule())\n\nAccording to @smith2020, this is true.\n\nBracketed: [@smith2020; @jones2021]","category":"section"},{"location":"extensions/#Auto-Identifiers","page":"Extensions","title":"Auto Identifiers","text":"Automatically generates IDs for headings based on their text. Enables linking directly to sections.\n\nparser = Parser()\nenable!(parser, AutoIdentifierRule())\n\nast = parser(\"# My Heading\")\nhtml(ast)\n\nIDs are slugified: lowercased, spaces become hyphens, special characters removed. Duplicate headings get numeric suffixes.","category":"section"},{"location":"extensions/#Reference-Links","page":"Extensions","title":"Reference Links","text":"Preserves reference-style link syntax in the AST instead of resolving it during parsing. Enables accurate markdown roundtripping.\n\nenable!(parser, ReferenceLinkRule())","category":"section"},{"location":"extensions/#Raw-Content","page":"Extensions","title":"Raw Content","text":"Pass format-specific content through unchanged. Useful for embedding LaTeX commands, HTML widgets, or other content that shouldn't be processed.\n\nenable!(parser, RawContentRule())\n\nThe format name (html, latex, typst) is specified in the attribute. The parser automatically determines inline vs block from context.\n\nInline: `<span>html</span>`{=html}\n\nBlock:\n```{=latex}\n\\textbf{LaTeX}\n```\n\nDefault formats: html, latex, typst. Custom formats can be added by passing type mappings to RawContentRule.","category":"section"}]
}
