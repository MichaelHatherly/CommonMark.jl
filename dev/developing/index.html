<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Developing Extensions · CommonMark.jl</title><meta name="title" content="Developing Extensions · CommonMark.jl"/><meta property="og:title" content="Developing Extensions · CommonMark.jl"/><meta property="twitter:title" content="Developing Extensions · CommonMark.jl"/><meta name="description" content="Documentation for CommonMark.jl."/><meta property="og:description" content="Documentation for CommonMark.jl."/><meta property="twitter:description" content="Documentation for CommonMark.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">CommonMark.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../core/">Core Rules</a></li><li><a class="tocitem" href="../extensions/">Extensions</a></li><li><a class="tocitem" href="../ast/">Building ASTs</a></li><li><a class="tocitem" href="../transforms/">Transforms</a></li><li class="is-active"><a class="tocitem" href>Developing Extensions</a><ul class="internal"><li><a class="tocitem" href="#AST-Nodes"><span>AST Nodes</span></a></li><li><a class="tocitem" href="#Rule-Interface"><span>Rule Interface</span></a></li><li><a class="tocitem" href="#Writer-Functions"><span>Writer Functions</span></a></li><li><a class="tocitem" href="#Parser-State"><span>Parser State</span></a></li><li><a class="tocitem" href="#Registration"><span>Registration</span></a></li><li><a class="tocitem" href="#Example:-Highlight-(Inline)"><span>Example: Highlight (Inline)</span></a></li><li><a class="tocitem" href="#Example:-Spoiler-Block"><span>Example: Spoiler Block</span></a></li><li><a class="tocitem" href="#Extension-Patterns"><span>Extension Patterns</span></a></li></ul></li><li><a class="tocitem" href="../api/">API Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Developing Extensions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Developing Extensions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/MichaelHatherly/CommonMark.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/MichaelHatherly/CommonMark.jl/blob/master/docs/src/developing.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Developing-Extensions"><a class="docs-heading-anchor" href="#Developing-Extensions">Developing Extensions</a><a id="Developing-Extensions-1"></a><a class="docs-heading-anchor-permalink" href="#Developing-Extensions" title="Permalink"></a></h1><div class="admonition is-warning" id="Internal-API-ce6e6464220d67c0"><header class="admonition-header">Internal API<a class="admonition-anchor" href="#Internal-API-ce6e6464220d67c0" title="Permalink"></a></header><div class="admonition-body"><p>This documents internal interfaces not covered by semantic versioning. These APIs may change between any versions without notice.</p></div></div><p>This page documents how to create custom parsing rules for CommonMark.jl. An extension consists of three parts: AST node types, parsing rules, and writer functions.</p><pre><code class="language-julia hljs">using CommonMark</code></pre><h2 id="AST-Nodes"><a class="docs-heading-anchor" href="#AST-Nodes">AST Nodes</a><a id="AST-Nodes-1"></a><a class="docs-heading-anchor-permalink" href="#AST-Nodes" title="Permalink"></a></h2><h3 id="Type-Hierarchy"><a class="docs-heading-anchor" href="#Type-Hierarchy">Type Hierarchy</a><a id="Type-Hierarchy-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Hierarchy" title="Permalink"></a></h3><p>All node types inherit from <code>AbstractContainer</code>:</p><pre><code class="language-julia hljs">abstract type AbstractContainer end
abstract type AbstractBlock &lt;: AbstractContainer end   # Block-level elements
abstract type AbstractInline &lt;: AbstractContainer end  # Inline elements</code></pre><p>Define your node type as a struct:</p><pre><code class="language-julia hljs">struct MyBlock &lt;: AbstractBlock
    info::String  # Store any data your extension needs
end

struct MyInline &lt;: AbstractInline end</code></pre><h3 id="The-Node-Struct"><a class="docs-heading-anchor" href="#The-Node-Struct">The Node Struct</a><a id="The-Node-Struct-1"></a><a class="docs-heading-anchor-permalink" href="#The-Node-Struct" title="Permalink"></a></h3><p>Nodes wrap your container type in a tree structure:</p><pre><code class="language-julia hljs">mutable struct Node
    t::AbstractContainer      # Your container type (MyBlock, MyInline, etc.)
    parent::Node              # Parent node
    first_child::Node         # First child
    last_child::Node          # Last child
    prv::Node                 # Previous sibling
    nxt::Node                 # Next sibling
    sourcepos::SourcePos      # Source position ((start_line, start_col), (end_line, end_col))
    literal::String           # Text content (for leaf nodes)
    meta::Dict{String,Any}    # Arbitrary metadata
end</code></pre><p>Use <code>isnull(node)</code> to check for null references (rather than checking against <code>nothing</code>).</p><h3 id="Container-Behavior-Methods"><a class="docs-heading-anchor" href="#Container-Behavior-Methods">Container Behavior Methods</a><a id="Container-Behavior-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Container-Behavior-Methods" title="Permalink"></a></h3><p>Define these methods to control how your node participates in parsing:</p><pre><code class="language-julia hljs"># Can this node contain children? Default: false
is_container(::MyBlock) = true

# Does this block accept raw text lines? (like code blocks)
accepts_lines(::MyBlock) = false

# Which child types are allowed? Default allows most types.
can_contain(::MyBlock, child) = !(child isa Item)

# Called when the block is closed. Default: nothing
finalize(::MyBlock, parser::Parser, node::Node) = nothing

# Called to check if this block continues on the next line.
# Return: 0 = continue, 1 = close block, 2 = close and skip line
function continue_(::MyBlock, parser::Parser, node::Node)
    if parser.indent &gt;= 4
        advance_offset(parser, 4, true)
        return 0  # Continue this block
    elseif parser.blank
        advance_next_nonspace(parser)
        return 0
    else
        return 1  # Close this block
    end
end</code></pre><h2 id="Rule-Interface"><a class="docs-heading-anchor" href="#Rule-Interface">Rule Interface</a><a id="Rule-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Rule-Interface" title="Permalink"></a></h2><h3 id="The-Rule-Struct"><a class="docs-heading-anchor" href="#The-Rule-Struct">The Rule Struct</a><a id="The-Rule-Struct-1"></a><a class="docs-heading-anchor-permalink" href="#The-Rule-Struct" title="Permalink"></a></h3><p>Rules wrap parsing functions with metadata:</p><pre><code class="language-julia hljs">struct Rule
    fn::Function       # The parsing function
    priority::Float64  # Lower priority runs first
    triggers::String   # Trigger characters (empty = all positions)
end

Rule(fn, priority, triggers = &quot;&quot;)</code></pre><p>Create rules with do-block syntax:</p><pre><code class="language-julia hljs">block_rule(::MyRule) = Rule(0.5, &quot;!&quot;) do parser, container
    # Parse logic here
    return 0
end</code></pre><h3 id="Rule-Hooks"><a class="docs-heading-anchor" href="#Rule-Hooks">Rule Hooks</a><a id="Rule-Hooks-1"></a><a class="docs-heading-anchor-permalink" href="#Rule-Hooks" title="Permalink"></a></h3><p>Define these methods on your rule type to register parsing functions:</p><table><tr><th style="text-align: right">Hook</th><th style="text-align: right">Purpose</th><th style="text-align: right">Signature</th></tr><tr><td style="text-align: right"><code>block_rule</code></td><td style="text-align: right">Parse block-level syntax</td><td style="text-align: right"><code>(parser, container) → 0/1/2</code></td></tr><tr><td style="text-align: right"><code>inline_rule</code></td><td style="text-align: right">Parse inline syntax</td><td style="text-align: right"><code>(parser, block) → Bool</code></td></tr><tr><td style="text-align: right"><code>block_modifier</code></td><td style="text-align: right">Transform blocks after parsing</td><td style="text-align: right"><code>(parser, block) → nothing</code></td></tr><tr><td style="text-align: right"><code>inline_modifier</code></td><td style="text-align: right">Transform inlines after parsing</td><td style="text-align: right"><code>(parser, block) → nothing</code></td></tr></table><p>All hooks return <code>nothing</code> by default (no rule registered).</p><h3 id="Block-Rule-Return-Values"><a class="docs-heading-anchor" href="#Block-Rule-Return-Values">Block Rule Return Values</a><a id="Block-Rule-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Block-Rule-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Value</th><th style="text-align: right">Meaning</th></tr><tr><td style="text-align: right">0</td><td style="text-align: right">No match</td></tr><tr><td style="text-align: right">1</td><td style="text-align: right">Matched container (keeps parsing children)</td></tr><tr><td style="text-align: right">2</td><td style="text-align: right">Matched leaf block (stops block parsing)</td></tr></table><h3 id="Inline-Rule-Return-Values"><a class="docs-heading-anchor" href="#Inline-Rule-Return-Values">Inline Rule Return Values</a><a id="Inline-Rule-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Inline-Rule-Return-Values" title="Permalink"></a></h3><table><tr><th style="text-align: right">Value</th><th style="text-align: right">Meaning</th></tr><tr><td style="text-align: right"><code>false</code></td><td style="text-align: right">No match, try next rule</td></tr><tr><td style="text-align: right"><code>true</code></td><td style="text-align: right">Matched and consumed input</td></tr></table><h3 id="Delimiter-Hooks"><a class="docs-heading-anchor" href="#Delimiter-Hooks">Delimiter Hooks</a><a id="Delimiter-Hooks-1"></a><a class="docs-heading-anchor-permalink" href="#Delimiter-Hooks" title="Permalink"></a></h3><p>For emphasis-like syntax (paired delimiters like <code>~~text~~</code>), use these hooks instead of writing custom inline parsing:</p><pre><code class="language-julia hljs"># Map (character, count) to node type
delim_nodes(::MyRule) = Dict((&#39;~&#39;, 2) =&gt; Strikethrough)

# Define flanking behavior: :standard, :underscore, or :permissive
flanking_rule(::MyRule) = (&#39;~&#39;, :standard)

# Optional: characters that use odd-match logic
uses_odd_match(::MyRule) = &#39;~&#39;</code></pre><p>When using delimiter hooks, your <code>inline_rule</code> should call <code>handle_delim</code>:</p><pre><code class="language-julia hljs">inline_rule(::MyRule) = Rule(1, &quot;~&quot;) do parser, block
    handle_delim(parser, &#39;~&#39;, block)
end
inline_modifier(::MyRule) = Rule(process_emphasis, 1)</code></pre><h2 id="Writer-Functions"><a class="docs-heading-anchor" href="#Writer-Functions">Writer Functions</a><a id="Writer-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Writer-Functions" title="Permalink"></a></h2><h3 id="Signature"><a class="docs-heading-anchor" href="#Signature">Signature</a><a id="Signature-1"></a><a class="docs-heading-anchor-permalink" href="#Signature" title="Permalink"></a></h3><p>Implement a writer for each output format:</p><pre><code class="language-julia hljs">function write_html(::MyBlock, renderer, node, enter)
    if enter
        tag(renderer, &quot;div&quot;, attributes(renderer, node, [&quot;class&quot; =&gt; &quot;my-block&quot;]))
    else
        tag(renderer, &quot;/div&quot;)
    end
end</code></pre><p>The <code>enter</code> parameter is <code>true</code> when entering the node, <code>false</code> when leaving. This allows generating opening/closing tags for containers.</p><h3 id="Required-Writers"><a class="docs-heading-anchor" href="#Required-Writers">Required Writers</a><a id="Required-Writers-1"></a><a class="docs-heading-anchor-permalink" href="#Required-Writers" title="Permalink"></a></h3><table><tr><th style="text-align: right">Function</th><th style="text-align: right">Output Format</th></tr><tr><td style="text-align: right"><code>write_html</code></td><td style="text-align: right">HTML</td></tr><tr><td style="text-align: right"><code>write_latex</code></td><td style="text-align: right">LaTeX</td></tr><tr><td style="text-align: right"><code>write_typst</code></td><td style="text-align: right">Typst</td></tr><tr><td style="text-align: right"><code>write_term</code></td><td style="text-align: right">Terminal (ANSI)</td></tr><tr><td style="text-align: right"><code>write_markdown</code></td><td style="text-align: right">Markdown (roundtrip)</td></tr><tr><td style="text-align: right"><code>write_json</code></td><td style="text-align: right">Pandoc AST JSON</td></tr></table><h3 id="Writer-Utilities"><a class="docs-heading-anchor" href="#Writer-Utilities">Writer Utilities</a><a id="Writer-Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#Writer-Utilities" title="Permalink"></a></h3><p><strong>HTML:</strong></p><ul><li><code>tag(w, name, attrs=[])</code> - emit HTML tag</li><li><code>attributes(w, node, extra=[])</code> - format attributes from node.meta</li></ul><p><strong>All formats:</strong></p><ul><li><code>literal(w, str...)</code> - emit raw text</li><li><code>cr(w)</code> - conditional newline (if not at line start)</li><li><code>print(w.buffer, str)</code> - direct buffer access</li></ul><p><strong>Terminal/Markdown:</strong></p><ul><li><code>push_margin!(w, prefix)</code> - add indentation prefix</li><li><code>pop_margin!(w)</code> - remove indentation prefix</li><li><code>print_margin(w)</code> - emit current margin</li></ul><p><strong>Terminal:</strong></p><ul><li><code>print_literal(w, crayon, text, inv(crayon))</code> - styled output</li></ul><h2 id="Parser-State"><a class="docs-heading-anchor" href="#Parser-State">Parser State</a><a id="Parser-State-1"></a><a class="docs-heading-anchor-permalink" href="#Parser-State" title="Permalink"></a></h2><p>Key parser fields available during block parsing:</p><pre><code class="language-julia hljs">parser.indent            # Current indentation level
parser.indented          # Is line indented &gt;= 4 spaces?
parser.blank             # Is current line blank?
parser.next_nonspace     # Position of next non-whitespace
parser.line_number       # Current line number

# Utility functions
rest_from_nonspace(parser)      # Get remaining line from next non-space
advance_offset(parser, n, cols) # Advance position by n chars
advance_next_nonspace(parser)   # Move to next non-space
advance_to_end(parser)          # Consume rest of line
close_unmatched_blocks(parser)  # Finalize pending blocks
add_child(parser, type, offset) # Create new child node</code></pre><p>For inline parsing:</p><pre><code class="language-julia hljs">trypeek(parser, Char)           # Peek current character
consume(parser, match)          # Consume regex match
append_child(block, node)       # Add inline child</code></pre><h2 id="Registration"><a class="docs-heading-anchor" href="#Registration">Registration</a><a id="Registration-1"></a><a class="docs-heading-anchor-permalink" href="#Registration" title="Permalink"></a></h2><p>Enable your rule with <code>enable!</code>:</p><pre><code class="language-julia hljs">parser = Parser()
enable!(parser, MyRule())</code></pre><p>Rules can be disabled with <code>disable!</code>:</p><pre><code class="language-julia hljs">disable!(parser, SetextHeadingRule())  # Only allow ATX headings</code></pre><h2 id="Example:-Highlight-(Inline)"><a class="docs-heading-anchor" href="#Example:-Highlight-(Inline)">Example: Highlight (Inline)</a><a id="Example:-Highlight-(Inline)-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Highlight-(Inline)" title="Permalink"></a></h2><p>A custom inline extension using delimiter hooks for <code>==highlighted text==</code> syntax.</p><pre><code class="language-julia hljs"># AST node
struct Highlight &lt;: CommonMark.AbstractInline end
CommonMark.is_container(::Highlight) = true

# Rule type
struct HighlightRule end

# Use delimiter infrastructure for ==text== parsing
CommonMark.inline_rule(::HighlightRule) = CommonMark.Rule(1, &quot;=&quot;) do parser, block
    CommonMark.handle_delim(parser, &#39;=&#39;, block)
end
CommonMark.inline_modifier(::HighlightRule) = CommonMark.Rule(CommonMark.process_emphasis, 1)
CommonMark.delim_nodes(::HighlightRule) = Dict((&#39;=&#39;, 2) =&gt; Highlight)
CommonMark.flanking_rule(::HighlightRule) = (&#39;=&#39;, :standard)

# Writers
CommonMark.write_html(::Highlight, r, n, ent) =
    CommonMark.tag(r, ent ? &quot;mark&quot; : &quot;/mark&quot;, ent ? CommonMark.attributes(r, n) : [])

CommonMark.write_latex(::Highlight, w, n, ent) =
    print(w.buffer, ent ? &quot;\\hl{&quot; : &quot;}&quot;)

CommonMark.write_term(::Highlight, w, n, ent) = nothing  # No terminal styling

CommonMark.write_markdown(::Highlight, w, n, ent) = CommonMark.literal(w, &quot;==&quot;)</code></pre><p>Usage:</p><pre><code class="language-julia hljs">parser = Parser()
enable!(parser, HighlightRule())
ast = parser(&quot;Some ==highlighted text== here.&quot;)
html(ast)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;&lt;p&gt;Some &lt;mark&gt;highlighted text&lt;/mark&gt; here.&lt;/p&gt;\n&quot;</code></pre><h2 id="Example:-Spoiler-Block"><a class="docs-heading-anchor" href="#Example:-Spoiler-Block">Example: Spoiler Block</a><a id="Example:-Spoiler-Block-1"></a><a class="docs-heading-anchor-permalink" href="#Example:-Spoiler-Block" title="Permalink"></a></h2><p>A custom block extension for spoiler/collapsible content using <code>??? title</code> syntax.</p><pre><code class="language-julia hljs"># AST node with title field
struct Spoiler &lt;: CommonMark.AbstractBlock
    title::String
end

# Container behavior
CommonMark.is_container(::Spoiler) = true
CommonMark.accepts_lines(::Spoiler) = false
CommonMark.can_contain(::Spoiler, t) = !(t isa CommonMark.Item)
CommonMark.finalize(::Spoiler, ::CommonMark.Parser, ::CommonMark.Node) = nothing

# Continue if indented by 4 spaces or blank
function CommonMark.continue_(::Spoiler, parser::CommonMark.Parser, ::CommonMark.Node)
    if parser.indent &gt;= 4
        CommonMark.advance_offset(parser, 4, true)
        return 0  # Continue
    elseif parser.blank
        CommonMark.advance_next_nonspace(parser)
        return 0
    else
        return 1  # Close
    end
end

# Rule type
struct SpoilerRule end

# Block parsing function
CommonMark.block_rule(::SpoilerRule) = CommonMark.Rule(0.5, &quot;?&quot;) do parser, container
    if !parser.indented
        ln = CommonMark.rest_from_nonspace(parser)
        m = match(r&quot;^\?\?\? (.+)$&quot;, ln)
        if m !== nothing
            CommonMark.close_unmatched_blocks(parser)
            CommonMark.add_child(parser, Spoiler(m[1]), parser.next_nonspace)
            CommonMark.advance_to_end(parser)
            return 1  # Container block
        end
    end
    return 0
end

# Writers
function CommonMark.write_html(s::Spoiler, rend, node, enter)
    if enter
        CommonMark.tag(rend, &quot;details&quot;, CommonMark.attributes(rend, node))
        CommonMark.tag(rend, &quot;summary&quot;)
        print(rend.buffer, s.title)
        CommonMark.tag(rend, &quot;/summary&quot;)
    else
        CommonMark.tag(rend, &quot;/details&quot;)
    end
end

CommonMark.write_latex(s::Spoiler, w, n, ent) =
    CommonMark.literal(w, ent ? &quot;\\begin{spoiler}{$(s.title)}\n&quot; : &quot;\\end{spoiler}\n&quot;)

CommonMark.write_term(::Spoiler, w, n, ent) = nothing

function CommonMark.write_markdown(s::Spoiler, w, node, ent)
    if ent
        CommonMark.push_margin!(w, &quot;    &quot;)
        CommonMark.literal(w, &quot;??? &quot;, s.title, &quot;\n&quot;)
        CommonMark.print_margin(w)
        CommonMark.literal(w, &quot;\n&quot;)
    else
        CommonMark.pop_margin!(w)
        CommonMark.cr(w)
    end
end</code></pre><p>Usage:</p><pre><code class="language-julia hljs">parser = Parser()
enable!(parser, SpoilerRule())
ast = parser(&quot;&quot;&quot;
??? Click to reveal
    This content is hidden by default.
    It can contain **formatted** text.
&quot;&quot;&quot;)
html(ast)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">&quot;&lt;details&gt;&lt;summary&gt;Click to reveal&lt;/summary&gt;\n&lt;p&gt;This content is hidden by default.\nIt can contain &lt;strong&gt;formatted&lt;/strong&gt; text.&lt;/p&gt;\n&lt;/details&gt;&quot;</code></pre><h2 id="Extension-Patterns"><a class="docs-heading-anchor" href="#Extension-Patterns">Extension Patterns</a><a id="Extension-Patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Extension-Patterns" title="Permalink"></a></h2><h3 id="Block-Modifier"><a class="docs-heading-anchor" href="#Block-Modifier">Block Modifier</a><a id="Block-Modifier-1"></a><a class="docs-heading-anchor-permalink" href="#Block-Modifier" title="Permalink"></a></h3><p>Transform existing nodes without custom parsing. Useful for detecting patterns in parsed content:</p><pre><code class="language-julia hljs">block_modifier(::MyRule) = Rule(50) do parser, block
    if block.t isa Paragraph
        # Check content and transform if needed
        m = match(r&quot;^pattern&quot;, block.literal)
        if m !== nothing
            block.t = MyCustomType()
        end
    end
end</code></pre><p>See <code>GitHubAlertRule</code> and <code>TaskListRule</code> for examples.</p><h3 id="Stateful-Rules"><a class="docs-heading-anchor" href="#Stateful-Rules">Stateful Rules</a><a id="Stateful-Rules-1"></a><a class="docs-heading-anchor-permalink" href="#Stateful-Rules" title="Permalink"></a></h3><p>Store state during parsing for cross-referencing:</p><pre><code class="language-julia hljs">struct FootnoteRule
    cache::Dict{String,Node}
    FootnoteRule() = new(Dict())
end

block_rule(fr::FootnoteRule) = Rule(0.5, &quot;[&quot;) do parser, container
    # Store definitions in cache
    fr.cache[id] = node
end

inline_rule(fr::FootnoteRule) = Rule(0.5, &quot;[&quot;) do parser, block
    # Reference cache to link footnotes
    def = get(fr.cache, id, nothing)
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../transforms/">« Transforms</a><a class="docs-footer-nextpage" href="../api/">API Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 8 January 2026 06:28">Thursday 8 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
